<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[anhoder的进阶日志]]></title>
  <link href="https://anhoder.github.io/atom.xml" rel="self"/>
  <link href="https://anhoder.github.io/"/>
  <updated>2020-12-20T21:21:23+08:00</updated>
  <id>https://anhoder.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[PHP扩展开发中常用的函数]]></title>
    <link href="https://anhoder.github.io/16078713339147.html"/>
    <updated>2020-12-13T22:55:33+08:00</updated>
    <id>https://anhoder.github.io/16078713339147.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">PHP函数相关</h2>

<pre><code class="language-c">
zend_parse_parameters()     // 解析函数参数
// 例如，s表示字符串, 解析一个字符串类型的参数到name, 及其长度到name_len: 
if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;s&quot;, &amp;name, &amp;name_len) == FAILURE) {
    RETURN_NULL();
}

/* 解析参数时的类型代码 */
b: 布尔类型（对应c类型: zend_bool）
l: 整型（long）
d: 浮点型（double）
s: 字符串（char*, int）
r: 资源型（zval*）
a: 数组（zval*）
o: 对象（zval*）
z: zval（zval*）
</code></pre>

<blockquote>
<p>附：PHP 7中使用FAST_ZPP方式解析函数参数的宏：<br/>
  <img src="media/16078683686223/16078723189095.jpg" alt=""/></p>
</blockquote>

<h2 id="toc_1">数组操作</h2>

<pre><code class="language-c">array_init(arr)                         // 初始化数组
add_next_index_null(zval*)              // 向数字索引的数组增加null
add_next_index_long(zval*, long)        // ...添加long类型
add_next_index_bool(zval*, 0|1)         // ...添加bool类型
add_next_index_double(zval*, double)  
add_next_index_string(zval*, char*, zend_bool)
add_next_index_zval(zval*, zval*)
// ...
</code></pre>

<p>更多操作数组的函数: <a href="https://www.php.net/manual/en/internals2.variables.arrays.php">https://www.php.net/manual/en/internals2.variables.arrays.php</a></p>

<blockquote>
<p>未完待续...</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP扩展开发中常用的宏函数]]></title>
    <link href="https://anhoder.github.io/16078683686223.html"/>
    <updated>2020-12-13T22:06:08+08:00</updated>
    <id>https://anhoder.github.io/16078683686223.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">zval类型相关</h2>

<pre><code class="language-c">
Z_TYPE(zval)        // 获取zval的类型
Z_TYPE_P(*zval)     // 获取*zval的类型
Z_TYPE_PP(**zval)   // 获取**zval的类型

/* zval类型相关常量 */
IS_NULL         // null 
IS_BOOL         // 布尔
IS_LONG         // 整型
IS_DOUBLE       // 浮点型
IS_STRING       // 字符串
IS_ARRAY        // 数组
IS_OBJECT       // 对象
IS_RESOURCE     // 资源

</code></pre>

<h2 id="toc_1">zval值相关</h2>

<pre><code class="language-c">//操作整数的
#define Z_LVAL(zval)            (zval).value.lval
#define Z_LVAL_P(zval_p)        Z_LVAL(*zval_p)
#define Z_LVAL_PP(zval_pp)      Z_LVAL(**zval_pp)

//操作IS_BOOL布尔型的
#define Z_BVAL(zval)            ((zend_bool)(zval).value.lval)
#define Z_BVAL_P(zval_p)        Z_BVAL(*zval_p)
#define Z_BVAL_PP(zval_pp)      Z_BVAL(**zval_pp)

//操作浮点数的
#define Z_DVAL(zval)            (zval).value.dval
#define Z_DVAL_P(zval_p)        Z_DVAL(*zval_p)
#define Z_DVAL_PP(zval_pp)      Z_DVAL(**zval_pp)

//操作字符串的值和长度的
#define Z_STRVAL(zval)          (zval).value.str.val
#define Z_STRVAL_P(zval_p)      Z_STRVAL(*zval_p)
#define Z_STRVAL_PP(zval_pp)        Z_STRVAL(**zval_pp)

#define Z_STRLEN(zval)          (zval).value.str.len
#define Z_STRLEN_P(zval_p)      Z_STRLEN(*zval_p)
#define Z_STRLEN_PP(zval_pp)        Z_STRLEN(**zval_pp)

#define Z_ARRVAL(zval)          (zval).value.ht
#define Z_ARRVAL_P(zval_p)      Z_ARRVAL(*zval_p)
#define Z_ARRVAL_PP(zval_pp)        Z_ARRVAL(**zval_pp)

//操作对象的
#define Z_OBJVAL(zval)          (zval).value.obj
#define Z_OBJVAL_P(zval_p)      Z_OBJVAL(*zval_p)
#define Z_OBJVAL_PP(zval_pp)        Z_OBJVAL(**zval_pp)

#define Z_OBJ_HANDLE(zval)      Z_OBJVAL(zval).handle
#define Z_OBJ_HANDLE_P(zval_p)      Z_OBJ_HANDLE(*zval_p)
#define Z_OBJ_HANDLE_PP(zval_p)     Z_OBJ_HANDLE(**zval_p)

#define Z_OBJ_HT(zval)          Z_OBJVAL(zval).handlers
#define Z_OBJ_HT_P(zval_p)      Z_OBJ_HT(*zval_p)
#define Z_OBJ_HT_PP(zval_p)     Z_OBJ_HT(**zval_p)

#define Z_OBJCE(zval)           zend_get_class_entry(&amp;(zval) TSRMLS_CC)
#define Z_OBJCE_P(zval_p)       Z_OBJCE(*zval_p)
#define Z_OBJCE_PP(zval_pp)     Z_OBJCE(**zval_pp)

#define Z_OBJPROP(zval)         Z_OBJ_HT((zval))-&gt;get_properties(&amp;(zval) TSRMLS_CC)
#define Z_OBJPROP_P(zval_p)     Z_OBJPROP(*zval_p)
#define Z_OBJPROP_PP(zval_pp)       Z_OBJPROP(**zval_pp)

#define Z_OBJ_HANDLER(zval, hf)     Z_OBJ_HT((zval))-&gt;hf
#define Z_OBJ_HANDLER_P(zval_p, h)  Z_OBJ_HANDLER(*zval_p, h)
#define Z_OBJ_HANDLER_PP(zval_p, h)     Z_OBJ_HANDLER(**zval_p, h)

#define Z_OBJDEBUG(zval,is_tmp)     (Z_OBJ_HANDLER((zval),get_debug_info)?  \
                        Z_OBJ_HANDLER((zval),get_debug_info)(&amp;(zval),&amp;is_tmp TSRMLS_CC): \
                        (is_tmp=0,Z_OBJ_HANDLER((zval),get_properties)?Z_OBJPROP(zval):NULL)) 
#define Z_OBJDEBUG_P(zval_p,is_tmp) Z_OBJDEBUG(*zval_p,is_tmp) 
#define Z_OBJDEBUG_PP(zval_pp,is_tmp)   Z_OBJDEBUG(**zval_pp,is_tmp)

//操作资源的
#define Z_RESVAL(zval)          (zval).value.lval
#define Z_RESVAL_P(zval_p)      Z_RESVAL(*zval_p)
#define Z_RESVAL_PP(zval_pp)        Z_RESVAL(**zval_pp)
</code></pre>

<h2 id="toc_2">创建zval</h2>

<pre><code class="language-c">ALLOC_ZVAL              // PHP 7中移除
ALLOC_INIT_ZVAL         // PHP 7中移除
MAKE_STD_ZVAL           // PHP 7中移除
// 例如：
zval *val; MAKE_STD_ZVAL(val);

ZVAL_LONG(*zval, long)      // 将整型值赋给*zval
ZVAL_NULL(*zval)            // null
ZVAL_BOOL(*zval, int)       // bool
ZVAL_TRUE(*zval)            // true
ZVAL_FALSE(*zval)           // false
ZVAL_LONG(*zval, long)      // long
ZVAL_DOUBLE(*zval, double)  // double
ZVAL_STRINGL(*zval,str,len,dup); // string with length
ZVAL_STRING(*zval, str, dup)     // string, dup指明了该字符串是否需要被复制。 值为 1 将先申请一块新内存并赋值该字符串，然后把新内存的地址复制给pzv， 为 0 时则是直接把str的地址赋值给zval。
ZVAL_RESOURCE(*zval, res);       // resource
</code></pre>

<h2 id="toc_3">函数相关</h2>

<pre><code class="language-c">ZEND_NUM_ARGS()             // 获取函数参数的数量

RETVAL_STRING(s)            // 函数返回字符串
RETURN_STRING(s)            // 函数返回字符串, #define RETURN_STRING(s) { RETVAL_STRING(s); return; }
RETURN_NULL()               // 函数返回null
RETURN_TRUE()               // 函数返回true
</code></pre>

<blockquote>
<p>附：PHP 7中使用FAST_ZPP方式解析函数参数的宏：<br/>
  <img src="media/16078683686223/16078723189095.jpg" alt=""/></p>
</blockquote>

<h2 id="toc_4">数组操作</h2>

<pre><code class="language-c">ZEND_HASH_FOREACH_VAL(ht, val)
ZEND_HASH_FOREACH_KEY(ht, h, key) 
ZEND_HASH_FOREACH_PTR(ht, ptr)
ZEND_HASH_FOREACH_NUM_KEY(ht, h) 
ZEND_HASH_FOREACH_STR_KEY(ht, key)
ZEND_HASH_FOREACH_STR_KEY_VAL(ht, key, val)
ZEND_HASH_FOREACH_KEY_VAL(ht, h, key, val)

// 例如：
ZEND_HASH_FOREACH_KEY_VAL(arr_hash, num_key, key, val) {
    //if (key) { //HASH_KEY_IS_STRING
    //}
    PHPWRITE(Z_STRVAL_P(val), Z_STRLEN_P(val));
    php_printf(&quot;\n&quot;);
}ZEND_HASH_FOREACH_END();
</code></pre>

<h2 id="toc_5">符号表</h2>

<p>PHP的变量存储在符号表中，不同作用域有不同的符号表。</p>

<pre><code class="language-c">struct _zend_executor_globals {
    ...
    HashTable symbol_table;         // 全局符号表
    HashTable *active_symbol_table; // 当前作用域符号表
    ...
};
</code></pre>

<pre><code class="language-c">EG(active_symbol_table)
EG(symbol_table)
ZEND_SET_SYMBOL(symbol, var_name, val)  // 设置变量到符号表
// 例如：
ZEND_SET_SYMBOL( EG(active_symbol_table) ,  &quot;foo&quot; , fooval);
</code></pre>

<blockquote>
<p>未完待续...</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[又一个命令行版网易云音乐——musicfox]]></title>
    <link href="https://anhoder.github.io/15981627088641.html"/>
    <updated>2020-08-23T14:05:08+08:00</updated>
    <id>https://anhoder.github.io/15981627088641.html</id>
    <content type="html"><![CDATA[
<p>musicfox是一款使用Dart编写的网易云音乐命令行程序。</p>

<p><img src="https://badgen.net/github/release/anhoder/musicfox" alt="last release"/> <img src="https://badgen.net/github/license/anhoder/musicfox" alt="GitHub"/> <img src="https://badgen.net/github/tag/anhoder/musicfox" alt="Last Tag"/> <img src="https://badgen.net/github/stars/anhoder/musicfox" alt="Star"/> <img src="https://badgen.net/github/last-commit/anhoder/musicfox" alt="GitHub last commit"/></p>

<h2 id="toc_0">一、为什么做这个项目</h2>

<p>在开始这个项目的之前，其实是已经有一个基于命令行的网易云音乐项目——<a href="https://github.com/darknessomi/musicbox" title="musicbox">musicbox</a>。</p>

<p>我也使用它听了很长一段时间的歌了，其中还贡献过一些代码，修复几个小问题。那为什么还要重新造一个轮子呢？</p>

<blockquote>
<ol>
<li>musicbox缺少一些我特别想要的功能</li>
<li>musicbox使用python进行编写，我对python并不是很熟悉，所以修改或者新增功能时比较麻烦</li>
</ol>
</blockquote>

<h2 id="toc_1">二、为什么使用Dart</h2>

<ul>
<li>Dart的语法极像Java，我本身也学过Java，因此学习成本较低；</li>
<li>Dart可以将代码编译成能在三大平台（Windows、Linux、Mac）上直接运行的可执行程序。</li>
</ul>

<h2 id="toc_2">三、效果预览</h2>

<p><img src="media/15981627088641/preview0.png" alt="欢迎界面"/></p>

<p><img src="media/15981627088641/preview1.png" alt="主界面1"/></p>

<p><img src="media/15981627088641/preview2.png" alt="主界面2"/></p>

<h2 id="toc_3">四、安装</h2>

<p>依赖mpg123，<strong>必须先安装mpg123</strong></p>

<h3 id="toc_4">Mac</h3>

<p>提供两种方式安装：</p>

<ol>
<li>进入到<a href="https://github.com/anhoder/musicfox/releases/latest" title="Release">Release</a>下载musicfox.mac文件，在iTerm或Terminal中运行</li>
<li>使用brew安装：
<code>sh
brew tap anhoder/musicfox &amp;&amp; brew install musicfox
</code></li>
</ol>

<h3 id="toc_5">Linux(Ubuntu)</h3>

<p>进入到<a href="https://github.com/anhoder/musicfox/releases/latest" title="Release">Release</a>下载musicfox.ubuntu文件，在终端中运行。</p>

<blockquote>
<p>本人没有Linux系统，该执行文件是在WSL2(Ubuntu 2004)下打包的，不确定其他Linux系统是否也能正常使用</p>
</blockquote>

<h3 id="toc_6">Windows</h3>

<p>下载<a href="./bin/musicfox.exe" title="Windows可执行文件">Windows可执行文件</a>，在命令行(推荐Windows Terminal)中运行即可。</p>

<p><strong>Windows下存在几个已知问题，暂时没有解决方法：</strong></p>

<ol>
<li>暂停时会延迟几秒，播放时不会延迟</li>
<li>登录或搜索输入时，会吞掉第一个字符</li>
<li>上、下、左、右及ESC键无法监听，只能使用字母代替这些操作</li>
<li>命令行窗口大小发生变化后，UI会变乱（因为Windows不支持resize事件）</li>
</ol>

<p><em>因为存在以上问题，所以推荐在WSL下使用，WSL的声音转发可以参考我的另一个<a href="https://github.com/anhoder/wsl-audio-musicbox" title="项目">项目</a></em>。</p>

<h2 id="toc_7">五、通知功能</h2>

<h3 id="toc_8">Mac</h3>

<p>Mac下默认使用<code>AppleScript</code>发送通知。如下：</p>

<p><img src="media/15981627088641/AppleScript.png" alt="AppleScript"/></p>

<p>如果想要更好的通知体验，可以安装<code>terminal-notifier</code>:</p>

<pre><code class="language-bash">brew install terminal-notifier
</code></pre>

<p>效果如下：</p>

<p><img src="media/15981627088641/terminal-notifier.png" alt="terminal-notifie"/></p>

<h3 id="toc_9">Linux</h3>

<p>Linux可以安装<code>libnotify-bin</code>来使用通知功能（未经测试）</p>

<h3 id="toc_10">Windows</h3>

<p>Windows下可以安装<code>notifu</code>实现通知，体验不太好（没找到其他更好的通知工具）</p>

<blockquote>
<p>当然，如果你有更好的命令行通知程序，你也可以自己实现INotifier接口达到你想要的效果：</p>

<pre><code class="language-dart">abstract class INotifier {
  // 检查该通知程序是否可用
  bool isAvailable();

  // 发送消息
  void send(String message, {String title, String subtitle, String soundName, String groupID, String activateID, String appIcon, String contentImage, String openURL, String executeCmd});
}
</code></pre>
</blockquote>

<h2 id="toc_11">六、使用</h2>

<pre><code class="language-bash">$ musicfox
</code></pre>

<p><strong>按键：</strong></p>

<table>
<thead>
<tr>
<th>按键</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>

<tbody>
<tr>
<td>h/H/LEFT</td>
<td>左</td>
<td>Windows只能使用<code>h</code></td>
</tr>
<tr>
<td>l/L/RIGHT</td>
<td>右</td>
<td>Windows只能使用<code>l</code></td>
</tr>
<tr>
<td>k/K/UP</td>
<td>上</td>
<td>Windows只能使用<code>k</code></td>
</tr>
<tr>
<td>j/J/DOWN</td>
<td>下</td>
<td>Windows只能使用<code>j</code></td>
</tr>
<tr>
<td>q/Q</td>
<td>退出</td>
<td>Windows只能使用<code>q</code></td>
</tr>
<tr>
<td>space</td>
<td>暂停/播放</td>
<td></td>
</tr>
<tr>
<td>[</td>
<td>上一曲</td>
<td></td>
</tr>
<tr>
<td>]</td>
<td>下一曲</td>
<td></td>
</tr>
<tr>
<td>-</td>
<td>减小音量</td>
<td></td>
</tr>
<tr>
<td>=</td>
<td>加大音量</td>
<td></td>
</tr>
<tr>
<td>n/N/ENTER</td>
<td>进入选中的菜单</td>
<td>Windows只能使用<code>n</code></td>
</tr>
<tr>
<td>b/B/ESC</td>
<td>返回上级菜单</td>
<td>Windows只能使用<code>b</code></td>
</tr>
<tr>
<td>w/W</td>
<td>退出并退出登录</td>
<td>Windows只能使用<code>w</code></td>
</tr>
<tr>
<td>p</td>
<td>切换播放方式</td>
<td></td>
</tr>
<tr>
<td>P</td>
<td>心动模式(仅在歌单中时有效)</td>
<td>Windows下使用<code>o</code></td>
</tr>
<tr>
<td>,</td>
<td>喜欢当前播放歌曲</td>
<td></td>
</tr>
<tr>
<td>&lt;</td>
<td>喜欢当前选中歌曲</td>
<td>Windows下使用<code>;</code></td>
</tr>
<tr>
<td>.</td>
<td>当前播放歌曲移除出喜欢</td>
<td></td>
</tr>
<tr>
<td>&gt;</td>
<td>当前选中歌曲移除出喜欢</td>
<td>Windows下使用<code>&#39;</code></td>
</tr>
<tr>
<td>/</td>
<td>标记当前播放歌曲为不喜欢</td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>标记当前选中歌曲为不喜欢</td>
<td>Windows下使用<code>\</code></td>
</tr>
</tbody>
</table>

<h2 id="toc_12">七、TODO</h2>

<ul>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 我的歌单</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 每日推荐歌曲</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 每日推荐歌单</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 私人FM</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 歌词显示</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 欢迎界面</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 搜索
<ul>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 按歌曲</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 按歌手</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 按歌词</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 按歌单</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 按专辑</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 按用户</li>
</ul></li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 排行榜</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 精选歌单</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 最新专辑</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 热门歌手</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 云盘</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 播放方式切换</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 喜欢/取消喜欢</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 心动模式/智能模式</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" /> 音乐电台 </li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" /> 将部分设置转化为文件可配置
<ul>
<li class="task-list-item"><input disabled="disabled" type="checkbox" /> 欢迎界面的欢迎语</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" /> 欢迎界面时长</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" /> 主题色</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" /> 歌词显示行数</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" /> ...</li>
</ul></li>
</ul>

<h2 id="toc_13">八、伴生项目</h2>

<p>在该项目的开发过程中，我将一些通用的功能模块单独抽离出来，做成了几个伴生项目：</p>

<ol>
<li><a href="https://github.com/anhoder/mp3_player" title="mp3_player">mp3_player</a>: dart命令行调用mpg123播放音乐</li>
<li><a href="https://github.com/anhoder/netease_music_request" title="netease_music_request">netease_music_request</a>: Dart实现的网易云音乐接口库，使用Dio发起请求，CookieJar管理Cookie信息</li>
<li><a href="https://github.com/anhoder/colorful_cmd" title="colorful_cmd">colorful_cmd</a>: 使用dart实现的一些命令行UI组件，如：WindowUI命令行窗口应用UI、RainbowProgress彩虹进度条、NotifierProxy三大平台通知代理、ColorText颜色文本...
<img src="media/15981627088641/command.png" alt="command"/>  <img src="media/15981627088641/rainbow_progress.png" alt="rainbow_progress"/>
<img src="media/15981627088641/window_ui.png" alt="window_ui"/>
<img src="media/15981627088641/window_ui2.png" alt="window_ui2"/></li>
</ol>

<h2 id="toc_14">九、感谢</h2>

<p>感谢以下项目及其贡献者们（不限于）：</p>

<ul>
<li><a href="https://github.com/darknessomi/musicbox" title="musicbox">musicbox</a></li>
<li><a href="https://github.com/Binaryify/NeteaseCloudMusicApi" title="NeteaseCloudMusicApi">NeteaseCloudMusicApi</a></li>
<li><a href="https://github.com/DirectMyFile/console.dart" title="console.dart">console.dart</a></li>
</ul>

<p><img src="media/15981627088641/wechat.png" alt="wechat"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用laravel的方式管理imi的路由]]></title>
    <link href="https://anhoder.github.io/15981633847284.html"/>
    <updated>2020-08-23T14:16:24+08:00</updated>
    <id>https://anhoder.github.io/15981633847284.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1、imi是什么</h2>

<p>imi与Swoft、Hyperf一样，是一个基于Swoole的PHP框架。</p>

<p><strong>不同之处在于，Swoft与Hyperf是主要针对微服务推出的框架，而imi致力于单体应用。</strong></p>

<p>此外，imi还支持代码热更新，只要监听的文件发生了更改，imi就会在很短的时间内重启服务。大体实现是：</p>

<blockquote>
<p>① 在worker进程的启动事件onWorkerStart中，载入相应的PHP文件。</p>

<p>② 当监听到代码更新后，向swoole发送一个SIGUSR1信号，swoole会重启所有的worker进程，并触发onWorkerStart事件，重新载入相应的PHP文件。此时，worker进程就是最新的代码了。</p>
</blockquote>

<p>虽然这个功能对于线上服务没有很大的帮助，但是却可以大大提高开发时效率。</p>

<h2 id="toc_1">2、imi的路由管理</h2>

<h3 id="toc_2">注解</h3>

<p>imi路由的管理方式与Swoft框架类似。使用<strong>注解</strong>来管理路由，例如：</p>

<pre><code class="language-php">&lt;?php
namespace Test;
 
use Imi\Controller\HttpController;
use Imi\Server\Route\Annotation\Route;
use Imi\Server\Route\Annotation\Action;
use Imi\Server\Route\Annotation\Controller;
 
/**
 * @Controller(prefix=&quot;home&quot;)
 */
class Index extends HttpController
{
    /**
     * @Action
     * @Route(url=&quot;/index&quot;)
     */
    public function index()
    {
        // 使用/index可以访问到
        return $this-&gt;response-&gt;write(&#39;hello imi!&#39;);
    }
    
    /**
     * @Action
     * @Route(url=&quot;test&quot;)
     */
    public function test()
    {
        // 使用/home/test可以访问到
        return $this-&gt;response-&gt;write(&#39;hello test!&#39;);
    }
}
</code></pre>

<p>上面的代码中，<code>Index</code>类上添加了<code>@Controller</code>注解，标识该类为一个控制器，并设置路由前缀为<code>home</code>；<code>index</code>及<code>test</code>方法上添加了<code>Action</code>、<code>Route</code>注解，并分别为它们设置路由为<code>/home</code>、<code>test</code>。</p>

<p>使用注解管理路由可以很直观地将控制器的方法和路由对应起来，但是它也会带来一些缺陷：</p>

<ul>
<li>当路由越来越多时，路由的管理就变得很复杂。例如：我们需要为一批路由添加一个中间件，此时，就需要修改很多文件。</li>
<li>路由结构不够清晰。</li>
</ul>

<h3 id="toc_3">配置</h3>

<p>当然，imi也支持使用配置的方式管理路由：</p>

<pre><code class="language-php">return [
    &#39;route&#39; =&gt; [
        [
            &#39;controller&#39; =&gt; \ImiDemo\HttpDemo\MainServer\Controller\Test::class,
            &#39;method&#39; =&gt; &#39;index&#39;,
            &#39;route&#39; =&gt; [
                &#39;url&#39; =&gt; &#39;/test&#39;,
                // &#39;method&#39;    =&gt;    &#39;PUT&#39;,
                // &#39;method&#39;    =&gt;    [&#39;GET&#39;, &#39;POST&#39;],
                // &#39;domain&#39;    =&gt;    &#39;{name}.xxx.com&#39;,
            ],
        ],
     ]
];
</code></pre>

<p>但是，这种方式存在多重嵌套，可读性并不高。</p>

<p>既然如此，还有什么其他路由管理方式呢？🤔</p>

<h2 id="toc_4">3、imi-route</h2>

<p>我认为laravel的路由管理方式是很方便且易读的，例如：</p>

<pre><code class="language-php">Route::group([&#39;middleware&#39; =&gt; [&#39;auth&#39;]], function () {
    Route::get(&#39;/auth/userinfo&#39;, &#39;AuthController@getUser&#39;);
});
</code></pre>

<p>所以，我编写了一个组件——<a href="https://github.com/anhoder/imi-route"><code>imi-route</code></a>，希望可以将laravel路由管理的基本功能应用到在imi框架中去。</p>

<h3 id="toc_5">基本实现思路</h3>

<p>首先，我们需要知道imi框架在启动时是如何加载相关路由的：</p>

<ol>
<li>解析应用目录下的所有文件，通过反射获取所有类的注释</li>
<li>注释通过字符串解析后得到相应注解，例如：路由注解为<code>RouteAnnotation</code></li>
<li>将所有的路由注解添加到HttpRoute中</li>
</ol>

<p>以上的流程都是在服务启动时进行处理，得到路由结果会常驻内存。</p>

<p>而<strong><code>imi-route</code>就是在服务启动时，将存储的路由转化为路由注解，添加到HttpRoute中。</strong></p>

<h3 id="toc_6">使用</h3>

<p>1、使用composer安装依赖：</p>

<pre><code class="language-bash">composer require alanalbert/imi-route
</code></pre>

<p>2、将下列代码添加到项目根目录的<code>Main.php</code>文件中：</p>

<pre><code class="language-php">&lt;?php
namespace ImiApp;

use Imi\Main\AppBaseMain;
  
class Main extends AppBaseMain
{
  public function __init()
  {
      \Alan\ImiRoute\Route::init(); // Add this line
  }

}
</code></pre>

<p>3、在项目根目录下，创建<code>route/route.php</code>目录及文件，在<code>route.php</code>文件中，你就可以管理你的路由了：</p>

<pre><code class="language-php">/**
 * @var $router Route
 */

use Alan\ImiRoute\Route;
use ImiApp\ApiServer\Controller\IndexController;
use ImiApp\ApiServer\Middleware\Test2Middleware;
use ImiApp\ApiServer\Middleware\TestMiddleware;

$router-&gt;group([&#39;middleware&#39; =&gt; TestMiddleware::class], function (Route $router) {

    $router-&gt;group(
        [
            &#39;middleware&#39; =&gt; Test2Middleware::class, 
            &#39;ignoreCase&#39; =&gt; true, 
            &#39;prefix&#39; =&gt; &#39;prefix&#39;
        ], function (Route $router) {
        $router-&gt;get(&#39;hi&#39;, &#39;ImiApp\ApiServer\Controller\IndexController@index&#39;);
    });

    $router-&gt;any(&#39;/hi/api/abc&#39;, [IndexController::class, &#39;index&#39;]);

    $router-&gt;any(&#39;/hi/api/{time}&#39;, [IndexController::class, &#39;api&#39;]);

});

$router-&gt;group([&#39;prefix&#39; =&gt; &#39;prefix&#39;], function (Route $router) {
    $router-&gt;get(&#39;/TEST/{time}&#39;, [IndexController::class, &#39;api&#39;]);
});
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windows的WSL音频解决方案]]></title>
    <link href="https://anhoder.github.io/15981627088961.html"/>
    <updated>2020-08-23T14:05:08+08:00</updated>
    <id>https://anhoder.github.io/15981627088961.html</id>
    <content type="html"><![CDATA[
<p>主要实现思路是使用pulseaudio进行音频转发，<a href="https://github.com/anhoder/wsl-audio-musicbox">wsl-audio-musicbox</a>项目主要是为了简化WSL与Windows之间通信转发的配置。</p>

<blockquote>
<p>可以实现在WSL中使用musicbox播放歌曲（<strong>给个Star吧~~</strong>）</p>
</blockquote>

<h2 id="toc_0">项目依赖</h2>

<ul>
<li>基于WSL2，WSL1未进行测试</li>
<li>基于ubuntu1804，其他需要修改代码</li>
<li>php-cli, 因为使用到PHP脚本处理文件内容</li>
</ul>

<h2 id="toc_1">原理</h2>

<p>使用pulseaudio软件将音频数据信号转发到Windows上，本项目只是将繁杂的配置进行自动化处理，并可以实现开机自启动</p>

<h2 id="toc_2">使用</h2>

<ol>
<li><p>Windows下安装pulseaudio软件</p></li>
<li><p>下载或clone本项目，将auto、etc目录移动或覆盖到pulseaudio的根目录下</p></li>
<li><p>启动WSL，安装pulseaudio: <code>sudo apt install pulseaudio</code>，如果没有php环境，执行<code>sudo apt install php-cli</code>进行安装。<strong>确保/etc/wsl.conf中有配置项</strong>：<code>generateResolvConf = true</code>（如果没有，需要添加上，并<strong>重启电脑</strong>）</p></li>
<li><p>Windows回到pulseaudio根目录，手动运行<code>auto</code>目录下的<code>start.bat</code>，出现<code>成功</code>表明一切顺利。（<strong>如果你在WSL中使用的不是zsh，则需要打开<code>auto/start.bat</code>文件，将ubuntu1804.exe run &quot;./start.php <code>echo ~/.zshrc</code> &amp;&amp; source ~/.zshrc&quot;中的<code>~/.zshrc</code>修改为你正在使用的环境变量文件，例如<code>~/.bashrc</code></strong></p></li>
<li><p><strong>关闭WSL并重新打开</strong>，运行<code>paplay -p /mnt/c/Windows/Media/Alarm04.wav</code>，如果有美妙的声音播放出来，恭喜你，音频转发成功了！！</p></li>
<li><p>如果你不想每次开机都手动执行一次<code>start.bat</code>，可以打开<code>auto/start.vbs</code>文件，将其中的<code>.\start.bat</code>替换为你电脑<code>start.bat</code>文件的<strong>绝对路径</strong>，并将start.vbs移动到Windows的自启动目录下（win+R运行<code>shell:startup</code>即可打开该目录）。重启试试看吧~</p></li>
</ol>

<h2 id="toc_3">使用musicbox</h2>

<blockquote>
<p>只需要根据musicbox项目的Linux系统安装指引进行安装即可~~</p>
</blockquote>

<p><img src="media/15981627088961/musicbox.png" alt="musicbox"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Atheme——基于MWeb的静态站点主题]]></title>
    <link href="https://anhoder.github.io/15981627089010.html"/>
    <updated>2020-08-23T14:05:08+08:00</updated>
    <id>https://anhoder.github.io/15981627089010.html</id>
    <content type="html"><![CDATA[
<p>最近总觉得我的博客主题有点丑，于是趁着假期优化一下（<strong><em>调样式真的累，特别是对于强迫症患者。。。😭</em></strong>）</p>

<h2 id="toc_0">MWeb是什么</h2>

<p>MWeb是Mac OS上的一个Markdown编辑器，其具备很多功能：</p>

<ul>
<li>发布图片到图床</li>
<li>直接发布文章到WordPress、印象笔记、语雀等站点</li>
<li>Markdown导出为图片、PDF、富文本、HTML等</li>
<li>设置页面主题</li>
<li>将Markdown编译为静态站点</li>
<li>...</li>
</ul>

<p>总而言之，MWeb是一款很优质的Markdown编辑器，搭配上Github Pages及Gitee Pages，简直不要太爽。</p>

<h2 id="toc_1">Atheme主题</h2>

<p>本文介绍的Atheme就是一款基于MWeb编辑器的可配置的静态站点主题。它是我在MWeb自带主题——<strong>BulmaCSS</strong>的基础上进行添加、修改、优化而出现的产物。以下主要介绍这个主题的主要功能：</p>

<ol>
<li>网站菜单</li>
<li>站长信息及联系方式</li>
<li>公告、分类及标签</li>
<li><strong>随机图片</strong></li>
<li><strong>暗黑模式</strong></li>
<li><strong>使用Github评论</strong></li>
<li><strong>看板娘</strong></li>
<li><strong>Google Analysis、Baidu Analysis</strong></li>
</ol>
<span style="color: #F4635F;">
<p><strong>！多图预警！</strong><br/>
<strong>！！多图预警！！</strong><br/>
<strong>！！！多图预警！！！</strong></p>
</span>
<h3 id="toc_2">1、网站菜单</h3>

<p>网站菜单是出现在站点头部的导航条，它是MWeb提供的基础功能，可以在<code>偏好设置-&gt;网站扩展-&gt;网站菜单</code>中进行个性化设置。</p>

<p><img src="media/15981627089010/15861393202173.jpg" alt="" style="width:707px;"/></p>

<p><strong>站点效果</strong></p>

<p><img src="media/15981627089010/15861393669174.jpg" alt="" style="width:1440px;"/></p>

<h3 id="toc_3">2、联系方式及站长信息</h3>

<p>联系方式、站长信息是出现在Header中的内容：</p>

<p><img src="media/15981627089010/15861398063524.jpg" alt="" style="width:1437px;"/></p>

<p>它们是Atheme主题提供的个性化功能，可以在<code>偏好设置-&gt;网站扩展-&gt;网站扩展设置</code>中进行配置，支持的配置项有：</p>

<ul>
<li>站长名</li>
<li>站长首页</li>
<li>站点icon</li>
<li>站长的头像</li>
<li>微博主页</li>
<li>Twitter</li>
<li>Github</li>
<li>Facebook</li>
<li>Instagram</li>
<li>YouTube</li>
<li>Stack Overflow</li>
<li>email</li>
<li>...</li>
</ul>

<h3 id="toc_4">3、公告、分类及标签</h3>

<ul>
<li>公告也是Atheme主题提供的配置功能，可以在<code>偏好设置-&gt;网站扩展-&gt;网站扩展设置</code>进行自定义配置。</li>
<li>分类及标签则是根据具体文章的分类、标签进行生成</li>
</ul>

<p><img src="media/15981627089010/15861406564340.jpg" alt="" style="width:426px;"/></p>

<h3 id="toc_5">4、随机图片</h3>

<p>随机图片，是在博客列表中针对每篇博客随机获取一张图片进行展示，随机图片的API也支持配置，我目前使用的有两个：</p>

<ul>
<li><a href="https://picsum.photos/1024/">https://picsum.photos/1024/</a></li>
<li><a href="https://source.unsplash.com/random/1024x">https://source.unsplash.com/random/1024x</a></li>
</ul>

<blockquote>
<p>需要注意的是，这个API必须支持设置图片的大小，并设置宽度为1024</p>
</blockquote>

<p><img src="media/15981627089010/15861412497796.jpg" alt="" style="width:844px;"/></p>

<h3 id="toc_6">5、暗黑模式</h3>

<p>暗黑模式暂不支持配置，目前是根据浏览器的外观偏好进行自动调整</p>

<p><img src="media/15981627089010/15861414640564.jpg" alt="" style="width:1474px;"/></p>

<p><img src="media/15981627089010/15861414308809.jpg" alt="" style="width:1518px;"/></p>

<h3 id="toc_7">6、使用Github评论</h3>

<p>使用Github账号进行评论是集成了utteranc插件，在使用之前需要准备一个Github仓库用于存放评论内容，并在配置(utteranc repo)中填入仓库名，例如：anhoder/blog-comment。</p>

<p><img src="media/15981627089010/15861418927019.jpg" alt="" style="width:973px;"/></p>

<blockquote>
<p>该模块主题也会根据日间、暗黑模式在github-light及github-dark之间进行切换。</p>

<p>Github头像👥可能会因为国内网络原因加载失败</p>
</blockquote>

<h3 id="toc_8">7、看板娘</h3>

<p>看板娘是出现在站点右下角，悬浮着的小人物或宠物。目前支持两种选择：</p>

<ol>
<li>血小板plt</li>
<li>黑猫或白猫</li>
</ol>

<p><img src="media/15981627089010/15861422315868.jpg" alt="" style="width:291px;"/></p>

<h3 id="toc_9">8、Google Analysis、Baidu Analysis</h3>

<p>该功能主要用于统计用户访问数，分析用户。你只需要在设置中配置Google Analysis ID及Baidu分析ID即可，也可以同时使用两个统计方案。</p>

<blockquote>
<p>百度分析ID为：<code>https://hm.baidu.com/hm.js?</code>后面的一串字符串</p>
</blockquote>

<h2 id="toc_10">总述</h2>

<p>以上就是Atheme主题目前的核心功能介绍，预览站点：<code>https://danlanhai.gitee.io</code>或<code>https://anhoder.github.io</code>。</p>

<p>如果以上内容对你有帮助或让你很感兴趣，<strong>请点击左下角「<span style="color:#028cca;">阅读原文</span>」，给个Star吧~~</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初探Docker---使用Docker Compose编排容器]]></title>
    <link href="https://anhoder.github.io/15981627591782.html"/>
    <updated>2020-08-23T14:05:59+08:00</updated>
    <id>https://anhoder.github.io/15981627591782.html</id>
    <content type="html"><![CDATA[
<p>使用Docker Compose将之前使用Docker搭建的PHP开发环境进行编排。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">什么是Docker Compose？</h2>

<p>Docker Compose是Docker官方编排项目之一，可以快速部署应用。</p>

<p>其使用一个单独的YAML文件（docker-compose.yml）来定义一组相关联的应用容器为一个项目。</p>

<p>Docker Compose不是必须使用的，你也可以只使用Docker来构建项目。Docker Compose只是提供一种更简单方便的方式来管理应用容器。</p>

<h2 id="toc_1">编排PHP开发环境</h2>

<pre><code class="language-yaml">version: &quot;3&quot;

## 网络
networks:
    frontend:
        driver: bridge
    backend:
        driver: bridge

services:
    ## PHP-FPM
    php-fpm:
        container_name: alan_php-fpm # 容器名
        build: 
            context: ./php-fpm
        volumes: 
            - ${WEBSITES_DIR}:/home/www # 站点目录
            - ${PHP_FPM_LOG_DIR}:/var/log/php-fpm # php-fpm日志
            - ${PHP_FPM_INI}:/usr/local/etc/php # php-fpm配置文件
        ports: 
            - &quot;${PHP_FPM_PORT}:9000&quot; # php-fpm端口
            - &quot;${SWOFT_PORT}:18306&quot;  # 预留swoft端口
        networks:
            - backend 

        
    ## Nginx
    nginx:
        container_name: alan_nginx # 容器名
        build:
            context: ./nginx 
        volumes: 
            - ${WEBSITES_DIR}:/home/www # 站点目录
            - ${NGINX_LOG_DIR}:/var/log/nginx # Nginx日志
            - ${NGINX_CONF}:/etc/nginx/conf.d # Nginx配置文件
        ports: 
            - &quot;${NGINX_PORT}:80&quot; # Nginx端口
        depends_on:
            - php-fpm # 依赖与php-fpm
        networks:
            - frontend
            - backend

    
    ## MySQL
    mysql:
        container_name: alan_mysql # 容器名
        build: 
            context: ./mysql
        volumes: 
            - ${MYSQL_DATA}:/var/lib/mysql # MySQL数据存储位置
            - ${MYSQL_CONF}:/etc/mysql/conf.d # MySQL配置文件
        ports: 
            - &quot;${MYSQL_PORT}:3306&quot; # MySQL端口
        environment:
            MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD} # MySQL的root密码
            MYSQL_USER: ${MYSQL_USER} # MySQL用户
            MYSQL_PASSWORD: ${MYSQL_PASSWORD} # MySQL密码
            MYSQL_ALLOW_EMPTY_PASSWORD: ${MYSQL_ALLOW_EMPTY_PASSWORD} # 是否允许空密码
        networks:
            - backend

    
    ## Redis
    redis:
        container_name: alan_redis #容器名
        build: 
            context: ./redis
        ports: 
            - &quot;${REDIS_PORT}:6379&quot; # Redis端口
        networks:
            - backend

</code></pre>

<p>其中的变量（例如：${REDIS_PORT}）可以在.env文件中进行自定义。</p>

<h2 id="toc_2">ENV环境变量文件示例</h2>

<p>.env配置文件的样例：</p>

<pre><code class="language-env"># web站点目录
WEBSITES_DIR=./www


## PHP-FPM
# PHP-FPM日志
PHP_FPM_LOG_DIR=./logs/php-fpm

# PHP-FPM配置
PHP_FPM_INI=./php-fpm/php

# PHP-FPM端口
PHP_FPM_PORT=9000

# SWOFT端口
SWOFT_PORT=18306


## Nginx
# Nginx日志
NGINX_LOG_DIR=./logs/nginx

# Nginx配置
NGINX_CONF=./nginx/sites

# Nginx端口
NGINX_PORT=8081


## MySQL
# MySQL数据
MYSQL_DATA=./data

# MySQL配置
MYSQL_CONF=./mysql/conf.d

# MySQL端口
MYSQL_PORT=3306


## Redis
# Redis端口
REDIS_PORT=6379
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初探Docker---编写Dockerfile搭建PHP开发环境]]></title>
    <link href="https://anhoder.github.io/15981627591823.html"/>
    <updated>2020-08-23T14:05:59+08:00</updated>
    <id>https://anhoder.github.io/15981627591823.html</id>
    <content type="html"><![CDATA[
<p>使用Dockerfile搭建PHP开发环境（之后添加docker-compose），项目地址见<strong>原文链接</strong>。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">一、编写Dockerfile</h2>

<h3 id="toc_1">1. PHP-FPM</h3>

<pre><code class="language-dockerfile">FROM php:7.2-fpm

LABEL maintainer=&quot;AlanAlbert&quot; version=&quot;1.0&quot; description=&quot;php-fpm(php 7.2)&quot;

# 设置时区
ENV TZ=Asia/Shanghai

# 复制php配置文件、php-fpm配置文件
COPY php.ini /usr/local/etc/php/
COPY php-fpm.conf /usr/local/etc/
COPY php-fpm.d/* /usr/local/etc/php-fpm.d/

# 安装PHP扩展——swoole、redis、pdo_mysql、mysqli
RUN docker-php-ext-install pdo_mysql mysqli \
    &amp;&amp; pecl install redis swoole \
    &amp;&amp; docker-php-ext-enable redis swoole

# 挂载站点目录、php-fpm日志目录为匿名卷
VOLUME /home/www /var/log/php-fpm

# 添加www用户及切换站点目录所有者
RUN useradd www \
    &amp;&amp; chown -R www /home/www

# 切换工作目录为根目录
WORKDIR /

# 容器启动时执行命令
CMD [&quot;/usr/local/sbin/php-fpm&quot;]

# 声明使用9000端口
EXPOSE 9000
</code></pre>

<h3 id="toc_2">2. Nginx</h3>

<pre><code class="language-dockerfile">FROM nginx

LABEL maintainer=&quot;AlanAlbert&quot; version=&quot;1.0&quot; description=&quot;nginx&quot;

# 设置时区
ENV TZ=Asia/Shanghai

# 复制Nginx配置
COPY nginx.conf /etc/nginx/
COPY sites/*.conf /etc/nginx/conf.d/

# 挂载站点、Nginx日志为匿名卷
VOLUME /home/www /var/log/nginx

# 添加www用户、更换站点目录所有者
RUN useradd www \
    &amp;&amp; chown -R www /home/www

# 设置工作目录
WORKDIR /home/www

# 设置容器启动时执行的命令
CMD [&quot;/usr/sbin/nginx&quot;]

# 声明使用的端口
EXPOSE 80 443
</code></pre>

<h3 id="toc_3">3. MySQL</h3>

<pre><code class="language-dockerfile">FROM mysql:5.7

LABEL maintainer=&quot;AlanAlbert&quot; version=&quot;1.0&quot; description=&quot;mysql&quot;

# 设置环境变量
ENV MYSQL_ALLOW_EMPTY_PASSWORD=true \
    MYSQL_ROOT_PASSWORD=&quot;&quot; \
    TZ=Asia/Shanghai

# 复制MySQL配置
COPY my.cnf /etc/mysql/

# 挂载MySQL数据目录为匿名卷
VOLUME /var/lib/mysql

# 声明使用的端口
EXPOSE 3306
</code></pre>

<h3 id="toc_4">4. Redis</h3>

<pre><code class="language-dockerfile">FROM redis

LABEL maintainer=&quot;AlanAlbert&quot; version=&quot;1.0&quot; description=&quot;redis&quot;

# 设置时区
ENV TZ=Asia/Shanghai

# 声明需要使用的端口
EXPOSE 6379
</code></pre>

<h2 id="toc_5">二、编写shell脚本管理容器</h2>

<p>因为暂时没有使用docker-compose，而docker命令较长，很复杂，所以编写脚本来管理容器</p>

<h3 id="toc_6">1. build</h3>

<pre><code class="language-bash">#!/bin/bash

# 发生错误，中断执行
set -e

echo &quot;开始构建...&quot;
echo &quot;正在构建PHP-FPM...&quot;

# 构建PHP-FPM镜像，并设置名称为alan/php-fpm
docker build -t alan/php-fpm php-fpm

# 创建PHP-FPM容器。
# 1. -p: 将容器9000端口映射到物理机9000端口；
# 2. --name: 指定名称为alan_php-fpm；
# 3. -i: 开启容器标准输入
# 4. -t: 分配一个伪输入终端
# 5. -v: 挂载www目录到/home/www、logs/php-fpm目录到/car/log/php-fpm
# 6. --network: 连接到alan_php_env网络
docker create -p 9000:9000 --name alan_php-fpm -it -v `pwd`/www:/home/www -v `pwd`/logs/php-fpm:/var/log/php-fpm --network alan_php_env alan/php-fpm

echo &quot;PHP-FPM构建完成.&quot;
echo &quot;正在构建Nginx...&quot;

# 构建Nginx镜像，设置名称为alan/nginx
docker build -t alan/nginx nginx

# 创建Nginx容器。
# 1. -p: 映射端口
# 2. --name: 设置镜像名称
# 3. -i: 开启标准输入
# 4. -t: 分配伪输入终端
# 5. -v: 挂载目录
# 6. --network: 连接网络
docker create -p 80:80 --name alan_nginx -it -v `pwd`/www:/home/www -v `pwd`/logs/nginx:/var/log/nginx --network alan_php_env alan/nginx

echo &quot;Nginx构建完成.&quot;
echo &quot;正在构建MySQL...&quot;

# 构建MySQL镜像
docker build -t alan/mysql mysql

# 创建MySQL容器
docker create -p 3306:3306 --name alan_mysql -it -v `pwd`/data:/var/lib/mysql --network alan_php_env alan/mysql

echo &quot;MySQL构建完成.&quot;
echo &quot;正在构建Redis...&quot;

# 构建Redis镜像
docker build -t alan/redis redis

# 创建Redis容器
# --requirepass: 设置Redis密码
docker create -p 6379:6379 --name alan_redis -it --network alan_php_env alan/redis --requirepass &quot;&quot;

echo &quot;Redis构建完成.&quot;
echo &quot;正在创建网络...&quot;

# 创建bridge网络
docker network create -d bridge alan_php_env

echo &quot;网络创建完成.&quot;
echo &quot;构建完成.&quot;
</code></pre>

<h3 id="toc_7">2. start</h3>

<pre><code class="language-bash">#!/bin/bash
set -e

echo &quot;正在启动...&quot;

# 启动所有容器
docker start alan_php-fpm alan_nginx alan_mysql alan_redis

echo &quot;启动完成.&quot;

</code></pre>

<h3 id="toc_8">3. stop</h3>

<pre><code class="language-bash">#!/bin/bash

echo &quot;正在停止...&quot;

# 停止所有容器
docker stop alan_redis alan_mysql alan_nginx alan_php-fpm

echo &quot;已停止.&quot;
</code></pre>

<h3 id="toc_9">4. restart</h3>

<pre><code class="language-bash">#!/bin/bash
set -e

echo &quot;正在重启...&quot;

# 重启所有镜像
docker restart alan_redis alan_mysql alan_nginx alan_php-fpm

echo &quot;重启完成.&quot;
</code></pre>

<h3 id="toc_10">5. uninstall</h3>

<pre><code class="language-bash">#!/bin/bash

# 停止所有容器 &amp;&amp; 删除所有容器 &amp;&amp; 删除所有镜像 &amp;&amp; 删除网络

echo &quot;正在卸载...&quot;
echo &quot;正在停止运行容器...&quot;

docker stop alan_redis alan_mysql alan_nginx alan_php-fpm

echo &quot;已停止.&quot;
echo &quot;正在删除容器...&quot;

docker rm alan_redis alan_mysql alan_nginx alan_php-fpm

echo &quot;已删除容器.&quot;
echo &quot;正在删除镜像...&quot;

docker rmi alan/redis alan/mysql alan/nginx alan/php-fpm

echo &quot;已删除镜像.&quot;
echo &quot;正在删除网络...&quot;

docker network rm alan_php_env

echo &quot;已删除网络.&quot;
echo &quot;卸载完成.&quot;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初探Docker---Docker及Dockerfile]]></title>
    <link href="https://anhoder.github.io/15981627591857.html"/>
    <updated>2020-08-23T14:05:59+08:00</updated>
    <id>https://anhoder.github.io/15981627591857.html</id>
    <content type="html"><![CDATA[
<p>学习Docker过程中自己的一些理解。</p>

<ul>
<li>什么是Docker、Dockerfile？</li>
<li>怎么使用Docker？</li>
<li>如何编写Dockerfile？</li>
</ul>

<span id="more"></span><!-- more -->

<h2 id="toc_0">1. 镜像</h2>

<p>镜像是一种特殊的文件系统，包含所需要的程序、资源、库、配置等文件，还有一些为运行时准备的配置参数。Docker镜像并不是一个文件，而是由多层文件系统联合组成的。镜像是一层一层构建的，而且删除前一层文件的操作并不是真的删除文件，而是将其标记为该文件已删除。</p>

<h2 id="toc_1">2. 容器</h2>

<p>容器是使用镜像来创建的，其类似于<code>类</code>与<code>对象</code>的关系：</p>

<ul>
<li>镜像是<code>类</code>，是静态的定义；</li>
<li>容器是实例化的<code>对象</code>，是动态运行时的实体。</li>
</ul>

<h2 id="toc_2">3. 仓库</h2>

<p><strong>仓库（Repository）</strong>是一个集中存储、分发镜像的场所，例如：存放Ubuntu镜像的仓库是Ubuntu仓库。另一个概念是<strong>注册服务器（Registry）</strong>，注册服务器是存放仓库的地方。</p>

<h2 id="toc_3">4. docker命令列表</h2>

<ul>
<li><code>docker help</code>: 获取帮助信息</li>
<li><code>docker exec</code>: 在正在运行的容器中运行命令</li>
<li><code>docker pull</code>: 从服务器提取镜像或存储库</li>
<li><code>docker ps</code>: 列出容器信息</li>
<li><code>docker images</code>: 列出所有镜像</li>
<li><code>docker build</code>: 通过Dockerfile构建镜像</li>
<li><code>docker create IMAGE</code>: 创建一个新的容器但不启动</li>
<li><code>docker run IMAGE [COMMAND]</code>: 创建一个新容器并运行一个命令</li>
<li><code>docker restart CONTAINER</code>: 重启容器</li>
<li><code>docker start CONTAINER</code>: 启动一个或多个容器</li>
<li><code>docker stop CONTAINER</code>: 停止容器</li>
<li><code>docker top CONTAINER</code>: 查看容器中运行的进程信息</li>
<li><code>docker rm</code>: 删除容器</li>
<li><code>docker rmi</code>: 删除镜像</li>
<li><code>docker volume</code>: 数据卷管理</li>
<li><code>docker network</code>: 网络管理</li>
<li><code>docker commit</code>: 从当前更改的容器状态创建新镜像</li>
<li><code>docker search</code>: 在服务器中搜索镜像</li>
<li><code>docker version</code>: 查看docker版本信息</li>
<li><code>docker attach</code>: 将本地输入、输出、错误流附加到正在运行的容器</li>
<li><code>docker history</code>: 查看镜像历史记录</li>
<li><code>docker info</code>: 显示设备信息</li>
<li><code>docker inspect</code>: 获取容器/镜像的元数据</li>
<li><code>docker login</code>: 登录到服务器</li>
<li><code>docker pause CONTAINER</code>: 暂停容器中所有的进程</li>
<li><code>docker unpause CONTAINER</code>: 恢复容器中的所有进程</li>
<li><code>docker kill CONTAINER</code>: 杀掉一个运行中的容器</li>
</ul>

<h2 id="toc_4">5. Dockerfile</h2>

<p>Dockerfile中提供了很多指令，以下将会提到这些指令的作用和用法。</p>

<h3 id="toc_5"><code>FROM</code></h3>

<ul>
<li><p>指定<strong>基础镜像</strong>。如: nginx, ubunu等。</p></li>
<li><p>还可以使用空白镜像(<code>scratch</code>)作为基础镜像。</p></li>
</ul>

<blockquote>
<p>使用：<code>FROM nginx</code>，或指定版本<code>FROM ubuntu:stretch</code></p>
</blockquote>

<h3 id="toc_6"><code>RUN</code></h3>

<ul>
<li><p>运行命令。</p></li>
<li><p>可以运行可执行文件：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code></p></li>
</ul>

<blockquote>
<p>使用：<code>RUN echo &#39;测试&#39; &gt; a.txt</code></p>
</blockquote>

<h3 id="toc_7"><code>COPY</code></h3>

<ul>
<li><p>复制文件。</p></li>
<li><p>可以使用通配符：<code>COPY *.txt /var/www/</code></p></li>
<li><p>可以指定复制后文件的所属用户及组：<code>COPY --chown=name a.txt /var/www/</code></p></li>
</ul>

<blockquote>
<p>使用：<code>COPY a.txt /var/www/</code></p>
</blockquote>

<h3 id="toc_8"><code>ADD</code></h3>

<ul>
<li><p>高级的<code>COPY</code>指令，可以指定URL。从URL下载的文件默认权限为600。</p></li>
<li><p>该命令可以用<code>RUN</code>指令执行<code>wget</code>或<code>curl</code>替换</p></li>
</ul>

<p><strong>不推荐使用</strong></p>

<h3 id="toc_9"><code>CMD</code></h3>

<ul>
<li><p>Docker容器启动时执行。</p></li>
<li><p>与RUN指令一样，该指令也支持exec、shell两种写法：<code>CMD &lt;命令&gt;</code>、 <code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></p></li>
<li><p>一个Dockerfile只能有一个CMD命令。</p></li>
</ul>

<blockquote>
<p>使用: <code>CMD [&quot;curl&quot;, &quot;-s&quot;, &quot;https://dogedoge.com&quot;]</code></p>
</blockquote>

<h3 id="toc_10"><code>ENTRYPOINT</code></h3>

<ul>
<li><p>与<code>CMD</code>指令一样，用于指定容器启动程序及参数。</p></li>
<li><p>同样支持exec及shell写法</p></li>
<li><p>与CMD指令的区别在于：command会作为参数传递给ENTRYPOINT指令</p></li>
</ul>

<blockquote>
<p>使用：<code>ENTRYPOINT [&quot;curl&quot;, &quot;-s&quot;, &quot;https://dogedoge.com&quot;]</code></p>
</blockquote>

<h3 id="toc_11"><code>ENV</code></h3>

<ul>
<li>设置环境变量</li>
</ul>

<blockquote>
<p>使用：<code>ENV &lt;key&gt; &lt;value&gt;</code> 或 <code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt; ...</code></p>
</blockquote>

<h3 id="toc_12"><code>ARG</code></h3>

<ul>
<li>与ENV指令效果一样，都是设置环境变量。但ARG设置的环境变量在容器运行时是不会存在的</li>
</ul>

<blockquote>
<p>使用：<code>ARG name=Alan</code></p>
</blockquote>

<h3 id="toc_13"><code>VOLUME</code></h3>

<ul>
<li><p>挂载匿名卷(volume)。为了防止用户在运行时忘记将动态文件所在的文件挂载为卷(docker -v)，我们可以事先在Dockerfile中指定挂载某些目录为匿名卷。</p></li>
<li><p>Docker运行时应保持容器存储层不发生写操作，容器存储层的数据在容器停止后不会持续存在。所以将数据写入到卷中，可以持久化存储数据，提高性能。</p></li>
</ul>

<blockquote>
<p>使用：<code>VOLUME /var/data</code></p>
</blockquote>

<h3 id="toc_14"><code>EXPOSE</code></h3>

<ul>
<li><p>声明打算使用的端口。</p></li>
<li><p>与<code>docker -p &lt;宿主端口&gt;:&lt;容器端口&gt;</code>不同，<code>EXPOSE</code>只是声明打算使用的端口，并不会自动做端口映射</p>
<blockquote>
<p>使用：<code>EXPOSE 8080</code></p>
</blockquote></li>
</ul>

<h3 id="toc_15"><code>WORKDIR</code></h3>

<ul>
<li>指定当前工作目录。</li>
</ul>

<blockquote>
<p>使用：<code>WORKDIR /var/data</code></p>
</blockquote>

<h3 id="toc_16"><code>USER</code></h3>

<ul>
<li>指定当前用户，<code>USER &lt;用户名&gt;:&lt;用户组&gt;</code></li>
</ul>

<blockquote>
<p>使用：<code>USER php</code></p>
</blockquote>

<h3 id="toc_17"><code>HEALTHCHECK</code></h3>

<ul>
<li>检查容器的健康状况</li>
</ul>

<blockquote>
<p>使用：<code>HEALTHCHECK [选项] CMD [命令]</code> 或 <code>HEALTHCHECK NONE</code></p>
</blockquote>

<h3 id="toc_18"><code>ONBUILD</code></h3>

<ul>
<li>当该镜像作为基础镜像被其他镜像使用时才会被执行。</li>
</ul>

<blockquote>
<p>使用：<code>ONBUILD RUN [&quot;npm&quot;, &quot;install&quot;]</code></p>
</blockquote>

<hr/>

<p><em>下一篇：<a href="#">初探Docker---编写Dockerfile搭建PHP的开发环境</a></em></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[百万级数据迁移、汇总]]></title>
    <link href="https://anhoder.github.io/15981630682166.html"/>
    <updated>2020-08-23T14:11:08+08:00</updated>
    <id>https://anhoder.github.io/15981630682166.html</id>
    <content type="html"><![CDATA[
<p>最近在工作中，需要对一些数据表的数据进行迁移及汇总，所以总结下自己遇到的问题及解决方案。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">一、数据迁移</h2>

<p>对百万级数据进行数据迁移。</p>

<h3 id="toc_1">1. 问题</h3>

<p>在进行迁移过程中，因为数据量比较大，且存在内存限制，因此将所有数据一次全部取出来是肯定不行的。那如何进行数据迁移呢？</p>

<h3 id="toc_2">2. 解决方法</h3>

<p>既然一次装不下所有数据，那就使用<strong>分段的形式</strong>来依次读取。</p>

<ul>
<li>说到分段读取，最先想到的就是使用MySQL提供的分段方式 <code>limit m,n</code> 来读取数据。</li>
</ul>

<blockquote>
<p>但是使用<code>limit m,n</code>进行分段取数据，MySQL需要首先计算出m行数据，然后往后取n条。因此当m值越大，查询速度就会越慢。</p>
</blockquote>

<ul>
<li>另外一种方式，用<code>where</code>条件查询来查询数据，进而让MySQL使用到索引。</li>
</ul>

<blockquote>
<p>每个数据表都会有一个自增ID，我们可以使用这个自增ID作为条件判断。每次取出数据后，都记录上次最后一行记录的ID，以作为下次取数据的判断依据。例如：</p>

<pre><code class="language-sql">SELECT * FROM `test` WHERE id&gt;2000 LIMIT 1000;
</code></pre>

<p>其中，2000就是上一次取出的数据中的最大ID。</p>
</blockquote>

<p>由此，我基于illuminate/database编写了一个类似于分页器的数据读取组件：</p>

<p>具体实现代码如下：</p>

<pre><code class="language-php">use AlanAlbert\Segmenter\Contract\Processor;
use Illuminate\Database\Eloquent\Model;
use \Exception;
use Illuminate\Database\Eloquent\Builder;
class Segmenter
{
    const ALL_ROWS = -1;
    
    /**
     * 源模型
     * @var array
     */
    protected $sourceModel = null;
    
    /**
     * 保存每个模型的最后一行主键id
     * @var int
     */
    private $lastRowId = -1;
    
    /**
     *模型中最大的ID
     * @var int
     */
    private $maxRowId = 0;
    
    /**
     * 一次处理的数据量
     * @var int
     */
    private $oneTimeRowNumber = -1;
    
    /**
     * 用于记录行数的列名（保证其在源模型中唯一性及递增性）
     * @var string
     */
    private $mainField = &#39;&#39;;
    
    /**
     * 需要获取的列
     * @var array|mixed
     */
    private $fields = [];
    
    /**
     * 数据表的别名
     * @var mixed|string
     */
    private $as = &#39;&#39;;
    
    /**
     * Segmenter构造函数
     *
     * @param Model|Builder $sourceModel
     * @param array $config
     *   配置的结构：
     *      [
     *          rows_number: 一次读取数据行数,
     *          main_field: 根据哪一列进行分段，默认取主键ID,
     *          fields: 需要获取的数据列,
     *          table_alias: 表的别名
     *      ]
     * 
     */
    public function __construct($sourceModel, array $config = [])
    {
        $this-&gt;sourceModel = $sourceModel;
        $this-&gt;oneTimeRowNumber = $config[&#39;rows_number&#39;] ?? self::ALL_ROWS;
        // 设置main_field
        if (isset($config[&#39;main_field&#39;]) &amp;&amp; !empty($config[&#39;main_field&#39;])) {
            $this-&gt;mainField = $config[&#39;main_field&#39;];
        } else {
            $this-&gt;mainField = $sourceModel instanceof Model ?
                $sourceModel-&gt;newInstance()-&gt;getKeyName() : 
                $sourceModel-&gt;newModelInstance()-&gt;getKeyName();
        }
        // 设置fields
        $this-&gt;fields = $config[&#39;fields&#39;] ?? [];
        // 设置表别名
        $tableName = $sourceModel instanceof Model ?
            $sourceModel-&gt;newInstance()-&gt;getTable() : 
            $sourceModel-&gt;newModelInstance()-&gt;getTable();
        $this-&gt;as = $config[&#39;table_alias&#39;] ?? $tableName;
        // 获取最大ID
        $maxRowId = (clone $sourceModel)
            -&gt;orderByDesc($this-&gt;as . &#39;.&#39; . $this-&gt;mainField)
            -&gt;limit(1)
            -&gt;value($this-&gt;mainField);
        $this-&gt;maxRowId = $maxRowId ?? 0;
        var_dump(&#39;最大ID: &#39; . $this-&gt;maxRowId);
    }
    
    /**
     * 迁移数据
     * @param Processor $processor 实现DataProcessor接口，主要处理读出后的数据
     * @param mixed ...$args 额外需要使用的参数
     * @return bool
     */
    public function execute(Processor $processor, ...$args): bool
    {
        // 循环读取数据，直至结尾
        while ($this-&gt;lastRowId &lt; $this-&gt;maxRowId) {
            if ($this-&gt;executeOneTime($processor, ...$args) === false) {
                return false;
            }
        }
    
        return true;
    }
    
    /**
     * 
     * @param Processor $processor
     * @param mixed ...$args
     * @return bool
     */
    protected function executeOneTime(Processor $processor, ...$args): bool
    {
        // 获取原始数据
        $sourceModel = $this-&gt;sourceModel
            -&gt;where($this-&gt;as . &#39;.&#39; . $this-&gt;mainField, &#39;&gt;&#39;, $this-&gt;lastRowId)
            -&gt;orderBy($this-&gt;as . &#39;.&#39; . $this-&gt;mainField);
        if ($this-&gt;oneTimeRowNumber &gt; 0) {
            $sourceModel = $sourceModel
                -&gt;limit($this-&gt;oneTimeRowNumber);
        }
        if (!empty($this-&gt;fields)) {
            $sourceData = $sourceModel
                -&gt;get(array_merge($this-&gt;fields, [$this-&gt;as . &#39;.&#39; . $this-&gt;mainField]));
        } else {
            $sourceData = $sourceModel
                -&gt;get();
        }
        
        // 更新当前ID
        $mainField = $this-&gt;mainField;
        $this-&gt;lastRowId = $sourceData-&gt;last()-&gt;$mainField;
        var_dump(&#39;当前ID: &#39; . $this-&gt;lastRowId . &#39;/&#39; . $this-&gt;maxRowId);
        return $processor-&gt;process($sourceData, ...$args);
    }
}
</code></pre>

<p><em>虽然最后工作中也没用到...</em></p>

<h2 id="toc_3">二、数据汇总</h2>

<p>对百万级数据进行分组汇总，举个简单的例子：统计出连锁网吧的用户数。</p>

<h3 id="toc_4">1. 问题</h3>

<p>如果选课表为<code>user_log</code>，网吧ID为<code>bar_id</code>，用户ID为<code>user_id</code>。统计的SQL语句可以为：</p>

<pre><code class="language-sql">SELECT COUNT(DISTINCT `bar_id`, `user_id`) AS `user_number` 
  FROM `user_log`;
</code></pre>

<p>但是这样存在一个问题：汇总的速度很慢，脚本运行时间需要用到<strong>一分半钟</strong>，这对于10分钟执行一次的脚本来说，时间有点长，如何优化呢？</p>

<h3 id="toc_5">2. 解决方法</h3>

<p>使用临时表：</p>

<ol>
<li>首先对表中的数据进行<code>group by</code>多列分组，将得到的结果作为临时表</li>
<li>对临时表中的数据进行统计</li>
</ol>

<p>例如：</p>

<pre><code class="language-sql">SELECT `bar_id`, COUNT(`bar_id`) AS `user_number`
  FROM (SELECT `bar_id` FROM `user_log` GROUP BY `bar_id`, `user_id`)
  GROUP BY `bar_id`;
</code></pre>

<h2 id="toc_6">三、其他问题</h2>

<p>当插入或更新的数据行很多时，出现占位符过多的的问题：<code>Prepared statement contains too many placeholders</code>。</p>

<blockquote>
<p>这是因为MySQL支持的占位符有数量限制（2<sup>16</sup> - 1），因此，可以使用<code>array_chunk</code>函数对需要的数据进行分块处理，然后依次插入。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP实现异步回调的总结]]></title>
    <link href="https://anhoder.github.io/15981638628871.html"/>
    <updated>2020-08-23T14:24:22+08:00</updated>
    <id>https://anhoder.github.io/15981638628871.html</id>
    <content type="html"><![CDATA[
<p>很久没更新博客了，最近在下班时间写了一个简单的PHP库——<a href="https://github.com/anhoder/php-async">php-async</a>及<a href="https://github.com/anhoder/php-async-manager">php-async-manager</a>，以实现PHP中的简单异步回调。</p>

<span id="more"></span><!-- more -->

<p><em>Mission Start!</em></p>

<h2 id="toc_0">0. 前言</h2>

<blockquote>
<p>最近遇到个问题，PHP的异步回调怎么实现？</p>
</blockquote>

<p>Workman、Swoole、fastcgi_finish_request？</p>

<ul>
<li>Workman、Swoole这些框架虽然对异步回调实现的很好，但是如果只需要简单的异步回调就上这些未免大材小用。</li>
<li>而fastcgi_finish_request虽然使用方面，但毕竟只能在php-fpm模式下使用，而且一次请求只能使用一次。</li>
</ul>

<p>之后就一直在思考：能不能自己实现一个PHP可用的简单异步回调呢？最初出现在我脑海的有几个方案：</p>

<ol>
<li>编写PHP扩展，使用C/C++创建守护进程进程，用于监听是否有异步任务到来，如果有任务到来，则执行任务及回调函数。而PHP进程则将异步任务传递给该监听进程，从而实现异步。</li>
<li>使用pcntl扩展创建子进程，并让子进程脱离父进程的控制，成为守护进程。子进程用于处理耗时的异步任务，父进程处理HTTP请求及返回响应。</li>
</ol>

<p>由于第二种方案更简单，因此选择使用第二种方案进行实现。</p>

<h2 id="toc_1">1. 实现原理及思路</h2>

<p>实现原理比较简单：</p>

<blockquote>
<ol>
<li>在当前进程中创建子进程，父进程处理耗时较短的HTTP业务逻辑；子进程处理耗时较长的任务，例如邮件发送等。</li>
<li>创建子进程后，让子进程脱离父进程的控制，成为守护进程。</li>
<li>父进程通过设置<code>Callable</code>或<code>Closure</code>函数，让子进程执行异步任务及回调函数。</li>
</ol>
</blockquote>

<p>每个异步任务都需要两个关键元素组成：异步任务本身、回调函数。所以设计了JobInterface接口，该接口要求实现两个方法：job、callback，分别对应异步任务及回调函数。具体代码为：</p>

<pre><code class="language-php">interface JobInterface
{
    /**
     * 异步任务
     *
     * @return void
     */
    public function job();

    /**
     * 回调函数
     *
     * @return void
     */
    public function callback();
}
</code></pre>

<h2 id="toc_2">2. 遇到的问题及解决方法</h2>

<p>在CLI模式下开发运行十分顺利，没遇到什么较大的问题。但是，一切开发完成之后，在php-fpm模式下测试，遇到以下几个问题：</p>

<h3 id="toc_3">问题</h3>

<ol>
<li><strong>创建的子进程由php-fpm管理进程控制</strong>，当子进程执行完成后，因为php-fpm没有给该异步进程“收尸”，<strong>导致其成为僵尸进程，占用系统资源</strong>。</li>
<li>因为在php-fpm模式下，进程受php-fpm管理进程的控制，因此猜测<strong>异步进程的数量可能受php-fpm配置的进程数限制</strong>。</li>
</ol>

<h3 id="toc_4">解决方案</h3>

<ol>
<li>对于“僵尸进程”的问题，让父进程忽略子进程的结束，从而将子进程的回收权移交给系统的init进程，由init进程回收创建的子进程：<code>pcntl_signal(SIGCHLD, SIG_IGN);</code>。</li>
<li>php-fpm配置的进程数限制，经过测试（将php-fpm配置文件中的最大进程数改为5，并使用静态模式）发现，并未出现猜想中的创建子进程被限制的问题。</li>
</ol>

<h2 id="toc_5">3. 最后结果</h2>

<p>最后实现的结果为: <a href="https://github.com/anhoder/php-async">php-async</a>。在CLI和php-fpm模式下都没有发现问题。</p>

<p>之后，我还基于symfony/console开发了一个用于查看异步任务的命令行工具——<a href="https://github.com/anhoder/php-async-manager">php-async-manager</a>，可以用于查看异步任务运行状态、停止正在运行的任务等。</p>

<h2 id="toc_6">4. 后续拓展</h2>

<p>该异步实现方案还存在一个很大的问题，即，每执行一个异步任务就要创建一个进程，当处理的请求数量比较多时，就需要创建太多的进程。</p>

<p>之后了解了NodeJS的异步实现原理，其底层使用libuv库，以事件为驱动，libuv负责将来自操作系统的事件收集起来，或者监视其他来源的事件。这样，用户就可以注册回调函数，回调函数会在事件发生的时候被调用。event-loop会一直保持运行状态。</p>

<p>因此，最好的异步实现方案还是使用C语言开发一个PHP的扩展😂。</p>

<p><em>Mission Complete!</em></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP的一些底层知识]]></title>
    <link href="https://anhoder.github.io/15981633177242.html"/>
    <updated>2020-08-23T14:15:17+08:00</updated>
    <id>https://anhoder.github.io/15981633177242.html</id>
    <content type="html"><![CDATA[
<p>自己在学习PHP底层时的一些笔记。</p>

<span id="more"></span><!-- more -->

<blockquote>
<p><em>阅读<a href="https://github.com/huanghantao/study-note/blob/master/PHP/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.md">https://github.com/huanghantao/study-note/blob/master/PHP/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.md</a>的笔记</em></p>
</blockquote>

<h2 id="toc_0">1. php-config</h2>

<p><code>php-config</code>是一个简单的命令行脚本，<strong>用于获取PHP的安装及配置信息</strong>。当安装多个PHP版本时，可以使用<code>--with-php-config</code>来指定使用哪个版本的PHP来进行编译。</p>

<h2 id="toc_1">2. PHP的扩展类型</h2>

<p>PHP的扩展可分为静态扩展和动态扩展两类。</p>

<ul>
<li>静态扩展是与PHP源码一起进行编译安装的，编译PHP时通过指定参数<code>--enable</code>和<code>--with</code>来启用扩展。</li>
<li>动态扩展是直接编译扩展的源代码，生成<code>.so</code>(Linux)或<code>.dll</code>(Windows)的动态链接库，然后在php.ini配置文件中开启。</li>
</ul>

<blockquote>
<p>在静态编译PHP时，enable 是启用 PHP 源码包自带，但是默认不启用的扩展，比如 ftp 和 exif 扩展。with 是指定扩展依赖的资源库的位置，如果是默认位置，就可以留空。</p>
</blockquote>

<h2 id="toc_2">3. PHP函数的底层实现</h2>

<p>PHP的函数分为两种，一种为内置函数<code>zend_internal_function</code>，另一种为用户函数<code>zend_user_function</code>。</p>

<ul>
<li>内置函数在PHP的内核实现，通过c/c++进行编写</li>
<li>用户函数是用户使用PHP自定义的函数，这种函数会被ZE(Zend Engine)编译为opcode来执行</li>
</ul>

<p>PHP在编译阶段将用户自定义的函数编译为独立的opcodes,保存在EG(function_table)中,调用时重新分配新的zend_execute_data(相当于运行栈),然后执行函数的opcodes,调用完再还原到旧的zend_execute_data，即原来的函数，继续执行。</p>

<p>zend_function的结构中的op_array存储了该函数中所有的操作,当函数被调用时,ZE就会将这个op_array中的opline一条条顺次执行, 并将最后的返回值返回。 从VLD扩展中查看的关于函数的信息可以看出,函数的定义和执行是分开的,一个函数可以作为一个独立的运行单元而存在。</p>

<h2 id="toc_3">4. PHP的线程安全</h2>

<p>配置编译PHP时加参数<code>--enable-maintainer-zts</code>则编译出的php为Zend线程安全（ZTS），否则不是线程安全（NTS）。</p>

<p>当<strong>使用pthread（POSIX threads）扩展时，或者当web服务器为Apache2 mpm-worker或IIS</strong>使用PHP作为模块时，请考虑使用ZTS。当<strong>使用FastCGI / FPM或Apache2 mpm-prefork</strong>时，您不需要ZTS，因为在PHP运行时使用的多进程处理。</p>

<p>NTS是运行PHP的首选方式。NTS还使您更容易编写和调试扩展。</p>

<h2 id="toc_4">5. Zend引擎的执行过程</h2>

<blockquote>
<ol>
<li>Zend Engine调用词法分析器将PHP脚本分割为一个一个的token</li>
<li>Zend Engine会将得到的token提交给语法分析器，生成抽象语法树(Abstract Syntax Tree)</li>
<li>ZE调用zend_compile_top_stmt()函数将抽象语法树解析为一个一个的opcode，opcode一般会以op_array的形式存在，它是PHP执行的中间语言</li>
<li>最后,ZE调用zend_executor来执行op_array，输出结果</li>
</ol>
</blockquote>

<h3 id="toc_5">Token</h3>

<p>PHP提供<code>token_get_all</code>函数来获取token，例如：</p>

<pre><code class="language-php">$token = token_get_all(&#39;&lt;?php echo \&#39;hello, world\&#39;;&#39;);
var_dump($token);
</code></pre>

<p>输出结果为：</p>

<pre><code class="language-bash">array(5) {
  [0] =&gt;
  array(3) {
    [0] =&gt;
    int(379)
    [1] =&gt;
    string(6) &quot;&lt;?php &quot;
    [2] =&gt;
    int(1)
  }
  [1] =&gt;
  array(3) {
    [0] =&gt;
    int(328)
    [1] =&gt;
    string(4) &quot;echo&quot;
    [2] =&gt;
    int(1)
  }
  [2] =&gt;
  array(3) {
    [0] =&gt;
    int(382)
    [1] =&gt;
    string(1) &quot; &quot;
    [2] =&gt;
    int(1)
  }
  [3] =&gt;
  array(3) {
    [0] =&gt;
    int(323)
    [1] =&gt;
    string(14) &quot;&#39;hello, world&#39;&quot;
    [2] =&gt;
    int(1)
  }
  [4] =&gt;
  string(1) &quot;;&quot;
}
</code></pre>

<h3 id="toc_6">AST抽象语法树</h3>

<p>以下工具可以用于查看AST结构信息：</p>

<ul>
<li><a href="https://pecl.php.net/package/ast">https://pecl.php.net/package/ast</a>  (扩展)</li>
<li><a href="https://dooakitestapp.herokuapp.com/phpast/webapp/">https://dooakitestapp.herokuapp.com/phpast/webapp/</a> (在线)</li>
<li><a href="https://github.com/nikic/PHP-Parser">https://github.com/nikic/PHP-Parser</a> (PHP解析工具)</li>
</ul>

<h3 id="toc_7">Opcode</h3>

<p>opcode是Zend虚拟机可识别的指令，php7共有173个opcode，定义在zend_vm_opcodes.h中，这些中间代码会被Zend VM(Zend虚拟机)直接执行。</p>

<p>查看opcode可以使用：</p>

<ul>
<li><a href="https://pecl.php.net/package/vld">https://pecl.php.net/package/vld</a> (扩展)</li>
<li><a href="https://3v4l.org/UBstu/vld#output">https://3v4l.org/UBstu/vld#output</a> (在线)</li>
</ul>

<h2 id="toc_8">6. EG变量</h2>

<p>executor_globals是一个全局变量，存储着许多信息(当前上下文、符号表、函数/类/常量表、堆栈等)，EG宏就是用于访问executor_globals的某个成员</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP中的fastcgi_finish_request函数]]></title>
    <link href="https://anhoder.github.io/15981638628901.html"/>
    <updated>2020-08-23T14:24:22+08:00</updated>
    <id>https://anhoder.github.io/15981638628901.html</id>
    <content type="html"><![CDATA[
<p>fastcgi_finish_request是<strong>工作在FastCGI模式下</strong>才可用的函数。使用这个脚本可以提高请求响应速度。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">CGI</h2>

<p>CGI，公共网关接口，是一种Web服务器与后端语言的通信规范。CGI会在请求到来时，fork出一个子进程用于处理请求，当处理完成后，会杀死该进程，下次请求到来时继续创建，如此往复...</p>

<p>因此，CGI在创建进程上会存在极大地资源消耗。现在使用较少。</p>

<h2 id="toc_1">FastCGI</h2>

<p>FastCGI可以说是CGI的升级版本，其解决了CGI在创建进程上的资源消耗。</p>

<p>具体方法为，当FastCGI进程管理器启动时，会创建若干个CGI进程（数量可配置）等待请求到来，不需要每次都花时间去创建，同时可以根据请求数对CGI进程数进行伸缩。</p>

<h2 id="toc_2">fastcgi_finish_request</h2>

<p>该函数就是<strong>工作在FastCGI模式下的</strong>。具体作用为，当执行到该函数时，直接向客户端返回响应，但后续脚本仍然执行，只是对用户不可见。</p>

<p>例如脚本文件a.php：</p>

<pre><code class="language-php">echo &#39;Hello, Alan&#39;;

fastcgi_finish_request();

sleep(5);
file_put_contents(&#39;a.txt&#39;, &#39;测试内容&#39;);
</code></pre>

<p>同时，使用tail命令监控a.txt文件的内容：</p>

<pre><code class="language-bash">$ tail -f -n 5 a.txt
</code></pre>

<p>启动Nginx、PHP-FPM，并访问a.php，可以发现很快就能得到响应，并不会受后面<code>sleep(5)</code>的影响，5秒之后a.txt文件也会出现<code>测试内容</code>。</p>

<h2 id="toc_3">其他</h2>

<p>因为该函数<strong>只能在FastCGI模式下可用</strong>，因此，如果需要考虑可移植性，可以自己根据业务逻辑实现fastcgi_finish_request函数：</p>

<pre><code class="language-php">if (!function_exists(&#39;fastcgi_finish_request&#39;)) {
  function fastcgi_finish_request() {
  
  }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP扩展之全局变量的使用]]></title>
    <link href="https://anhoder.github.io/15981633177280.html"/>
    <updated>2020-08-23T14:15:17+08:00</updated>
    <id>https://anhoder.github.io/15981633177280.html</id>
    <content type="html"><![CDATA[
<p>使用C语言开发PHP扩展时可能需要使用到全局变量，在使用全局变量时涉及到线程安全的问题，PHP设计了TSRM(线程安全资源管理器)来解决这个问题。在扩展开发中需要按照TSRM的规范定义全局变量。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">ZEND_BEGIN_MODULE_GLOBALS、ZEND_END_MODULE_GLOBALS</h2>

<p>PHP为扩展的全局变量提供一种存储方式：每个扩展将自己所有的全局变量统一定义在结构体中，然后将这个结构体注册到TSRM中。</p>

<p>ZEND_BEGIN_MODULE_GLOBALS、ZEND_END_MODULE_GLOBALS便是用来定义这个结构体的。使用方式为：</p>

<pre><code class="language-c">ZEND_BEGIN_MODULE_GLOBALS(extension_name)
    zend_long   val
    HashTable   table
ZEND_END_MODULE_GLOBALS(extension_name)
</code></pre>

<h2 id="toc_1">ZEND_DECLARE_MODULE_GLOBALS</h2>

<p>定义好存储全局变量的结构体后，便需要将该结构体注册进TSRM中。ZEND_DECLARE_MODULE_GLOBALS宏就是用于处理这个操作。</p>

<pre><code class="language-c">ZEND_DECLARE_MODULE_GLOBALS(extension_name)
</code></pre>

<h2 id="toc_2">ZEND_MODULE_GLOBALS_ACCESSOR</h2>

<p>访问扩展中定义的全局变量：</p>

<pre><code class="language-c">ZEND_MODULE_GLOBALS_ACCESSOR(extension_name, val)
</code></pre>

<p>当然你也可以自己定义一个宏进行访问：</p>

<pre><code class="language-c">#define TEST_G(val) ZEND_MODULE_GLOBALS_ACCESSOR(extension_name, val)
</code></pre>

<blockquote>
<p>需要注意的是，在一个PHP扩展中并不是只能定义一个全局变量结构体，数量是不限制的。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[config.m4详解]]></title>
    <link href="https://anhoder.github.io/15981633177311.html"/>
    <updated>2020-08-23T14:15:17+08:00</updated>
    <id>https://anhoder.github.io/15981633177311.html</id>
    <content type="html"><![CDATA[
<p>config.m4是扩展的编译配置文件，其会被包含到configure.in中，最终被autoconf编译为configure。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">PHP提供的宏</h2>

<h3 id="toc_1">PHP_ARG_WITH(arg_name, check_message, help_info)</h3>

<ul>
<li>定义一个<code>--with-param[=arg]</code>的编译参数。</li>
<li>这个宏有五个参数，但常用的是前三个。第一个参数为<code>参数名</code>，第二个参数为<code>执行./configure时的展示信息</code>，第三个参数为<code>执行 --help 时的展示信息</code>。</li>
<li>该宏定义的参数可以在config.m4中通过<code>$PHP_大写参数名</code>的形式进行访问。</li>
</ul>

<p>例如：</p>

<pre><code class="language-php">PHP_ARG_WITH(extname, for extname support, [--with-extname=yes])
# 通过$PHP_EXTNAME即可获得--with-extname=yes中的yes
</code></pre>

<h3 id="toc_2">PHP_ARG_ENABLE(arg_name, check_message, help_info)</h3>

<ul>
<li>定义一个<code>--enable-param[=arg]</code>或<code>--disable-param</code>（等价于<code>--enable-param=no</code>）</li>
<li>该宏与<code>PHP_ARG_WITH</code>类似，如果参数需要设置具体的值，则使用<code>PHP_ARG_WITH</code>，否则使用<code>PHP_ARG_ENABLE</code></li>
</ul>

<h3 id="toc_3">AC_MSG_CHECKING、AC_MSG_RESULT、AC_MSG_ERROR</h3>

<ul>
<li>AC_MSG_CHECKING([提示信息]): 在执行./configure时，check的提示信息。</li>
<li>AC_MSH_RESULT([检测的路径]): 结束check，继续执行</li>
<li>AC_MSG_ERROR([错误信息]): 输出错误信息并退出./configure的执行</li>
</ul>

<h3 id="toc_4">AC_DEFINE(variable, value, [description])</h3>

<ul>
<li>定义一个宏，例如：<code>AC_DEFINE(DEBUG_MODEL, 1, [open debug model])</code>，最终会执行<code>#define DEBUG_MODEL 1</code></li>
</ul>

<h3 id="toc_5">PHP_ADD_INCLUDE(path)</h3>

<ul>
<li>添加include路径，相当于<code>#include &quot;file&quot;</code></li>
<li>引用外部库或分为多个目录时会使用到</li>
</ul>

<h3 id="toc_6">PHP_CHECK_LIBRARY(library, function [, action-found [, action-not-found [, extra-libs]]])</h3>

<ul>
<li>检查依赖库library中是否存在需要的function，action-found为存在时执行的动作，action-not-found是不存在时执行的动作</li>
</ul>

<p>例如：</p>

<pre><code class="language-php">PHP_CHECK_LIBRARY($EXAMPLE_LIB_NAME, example_critical_function, [
  dnl 添加所需的 include 目录
  PHP_EVAL_INCLINE($EXAMPLE_INCDIRS)
  dnl 添加所需的扩展库及扩展库所在目录
  PHP_EVAL_LIBLINE($EXAMPLE_LIBS, EXAMPLE_SHARED_LIBADD)
],[
  dnl 跳出
  AC_MSG_ERROR([example library not found. Check config.log for more information.])
],[$EXAMPLE_LIBS])
</code></pre>

<h3 id="toc_7">AC_CHECK_FUNC(function, [action-if-found], [action-if-not-found])</h3>

<ul>
<li>检查函数function是否存在，action-if-found为存在时执行的动作，action-if-not-found为不存在时执行的动作</li>
</ul>

<h3 id="toc_8">PHP_ADD_LIBRARY_WITH_PATH</h3>

<ul>
<li>格式为：<code>PHP_ADD_LIBRARY_WITH_PATH($LIBNAME, $XXX_DIR/$PHP_LIBDIR, XXX_SHARED_LIBADD)</code>，添加链接库</li>
</ul>

<p>例如：</p>

<pre><code class="language-php">PHP_ADD_LIBRARY_WITH_PATH(example-extra, $PHP_EXAMPLE_EXTRA/lib, EXAMPLE_SHARED_LIBADD)
</code></pre>

<h3 id="toc_9">PHP_ADD_BUILD_DIR</h3>

<ul>
<li>加载所需所有C文件</li>
</ul>

<h3 id="toc_10">PHP_REQUIRE_CXX()</h3>

<ul>
<li>使用C++进行开发</li>
</ul>

<h3 id="toc_11">PHP_SUBST(XXX_SHARED_LIBADD)</h3>

<ul>
<li>扩展编译成动态链接库的形式</li>
</ul>

<h3 id="toc_12">PHP_NEW_EXTENSION(extname, sources , $ext_shared [, sapi_class [, extra-cflags [, cxx [, zend_ext]]]])</h3>

<ul>
<li>注册一个扩展</li>
<li>第一个参数是扩展的名称，和包含它的目录同名</li>
<li>第二个参数是做为扩展的一部分的所有源文件的列表</li>
<li>第三个参数总是 $ext_shared</li>
<li>第四个参数指定一个“SAPI 类”，仅用于专门需要 CGI 或 CLI SAPI 的扩展</li>
<li>第五个参数指定了构建时要加入 CFLAGS 的标志列表</li>
<li>第六个参数是一个布尔值，为 &quot;yes&quot; 时会强迫整个扩展使用 <code>$CXX</code> 代替 <code>$CC</code> 来构建</li>
<li>第三个以后的所有参数都是可选的</li>
</ul>

<p>例如：</p>

<pre><code class="language-php">PHP_NEW_EXTENSION(example, example.c $EXAMPLE_SOURCES, $ext_shared)
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP扩展编写]]></title>
    <link href="https://anhoder.github.io/15981633177343.html"/>
    <updated>2020-08-23T14:15:17+08:00</updated>
    <id>https://anhoder.github.io/15981633177343.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<p><em>Mission Start!</em></p>

<p>PHP的扩展分为两类：PHP扩展、Zend扩展，在内核中分别称为module、extension，以下的主要是关于module的内容。    </p>

<p>扩展可以在编译PHP时一起编译（静态编译），也可以将扩展编译为共享库，然后在配置文件php.ini中加入进去。</p>

<h2 id="toc_0">加载PHP扩展的过程</h2>

<p><a href="https://blog.alan123.xyz/php/592.html">PHP生命周期</a>有5个阶段：模块初始化阶段（php_module_startup）、请求初始化阶段（php_request_startup）、脚本执行阶段（script execute）、请求关闭阶段（php_request_shutdown()）、模块关闭阶段（php_module_shutdown()）。    </p>

<blockquote>
<p>① PHP扩展会在模块初始化阶段解析php.ini配置文件，将相对应的扩展共享库加载到PHP中，保存在全局变量extension_lists中；<br/><br/>
② 在php_ini_register_extensions()中依次遍历php_extension_lists.engine、php_extension_lists.functions，然后分别调用php_load_zend_extension_cb()、php_load_php_extension_cb()完成Zend扩展、PHP扩展的注册加载。</p>
</blockquote>

<h2 id="toc_1">扩展的组成</h2>

<p>① 通过zend_module_entry结构体来定义扩展的相关信息，包括扩展名称、版本号、hook函数等。且zend_module_entry结构体声明的变量名称需要遵循modulename_module_entry的格式。    </p>

<blockquote>
<ul>
<li><strong>name</strong>: 扩展名称</li>
<li><strong>functions</strong>: 扩展定义的内部函数entry</li>
<li><strong>module_startup_func</strong>: 在模块初始化阶段回调的hook函数</li>
<li><strong>module_shutdown_func</strong>: 在模块关闭阶段回调的hook函数</li>
<li><strong>request_startup_func</strong>: 在请求初始化阶段回调的hook函数</li>
<li><strong>request_shutdown_func</strong>: 在请求关闭阶段回调的hook函数</li>
<li><strong>info_func</strong>: php_info()函数时调用</li>
<li><strong>version</strong>: 扩展的版本信息</li>
</ul>
</blockquote>

<p>② 定义宏ZEND_GET_MODULE(extension_name)以获取扩展的zend_module_entry结构地址：    </p>

<pre><code class="language-c">ZEND_GET_MODULE(extension_name)
</code></pre>
<br />
<p>在PHP中，ZEND_GET_MODULE宏的定义如下：</p>

<pre><code class="language-c">#define ZEND_GET_MODULE(name) \
    BEGIN_EXTERN_C() \
    ZEND_DLEXPORT zend_module_entry *get_module(void) { return &amp;name##_module_entry; } \    // ##起到拼接字符串的作用
    END_EXTERN_C()
</code></pre>

<h2 id="toc_2">开发PHP扩展的步骤</h2>

<h3 id="toc_3">1、ext_skel生成扩展基本框架</h3>

<p>通过ext_skel脚本生成扩展的基本框架，ext_skel在PHP源码的ext目录下，使用方法：    </p>

<pre><code class="language-bash">./ext_skel --extname=extension_name
</code></pre>

<p>生成的目录框架如下：    </p>

<pre><code class="language-bash">$ ./ext_skel --extname=TestExtension

TestExtension
├── CREDITS
├── EXPERIMENTAL
├── TestExtension.c     // 扩展源码
├── TestExtension.php   // 用于在PHP中测试扩展是否可用，可去除
├── config.m4           // 扩展编译时的配置文件，用于phpize脚本生成configure文件
├── config.w32          // windows环境的配置
├── php_TestExtension.h // 头文件
└── tests               // 测试用例，用于make test的测试
    └── 001.phpt
</code></pre>

<h3 id="toc_4">2、修改config.m4配置</h3>

<p><a href="mweblib://15629867837001">config.m4详解</a><br/>
<a href="https://www.php.net/manual/zh/internals2.buildsys.configunix.php">PHP官网</a></p>

<p>以下为PHP官方文档给出的config.m4样例</p>

<pre><code class="language-m4">dnl $Id$
dnl config.m4 for extension example
PHP_ARG_WITH(example, for example support,
[  --with-example[=FILE]       Include example support. File is the optional path to example-config])
PHP_ARG_ENABLE(example-debug, whether to enable debugging support in example,
[  --enable-example-debug        example: Enable debugging support in example], no, no)
PHP_ARG_WITH(example-extra, for extra libraries for example,
[  --with-example-extra=DIR      example: Location of extra libraries for example], no, no)

dnl 检测扩展是否已启用
if test &quot;$PHP_EXAMPLE&quot; != &quot;no&quot;; then
  
  dnl 检测 example-config。首先尝试所给出的路径，然后在 $PATH 中寻找
  AC_MSG_CHECKING([for example-config])
  EXAMPLE_CONFIG=&quot;example-config&quot;
  if test &quot;$PHP_EXAMPLE&quot; != &quot;yes&quot;; then
    EXAMPLE_PATH=$PHP_EXAMPLE
  else
    EXAMPLE_PATH=`$php_shtool path $EXAMPLE_CONFIG`
  fi
  
  dnl 如果找到可用的 example-config，就使用它（检测文件是否存在，是否可执行以及执行的结果）
  if test -f &quot;$EXAMPLE_PATH&quot; &amp;&amp; test -x &quot;$EXAMPLE_PATH&quot; &amp;&amp; $EXAMPLE_PATH --version &gt; /dev/null 2&gt;&amp;1; then
    AC_MSG_RESULT([$EXAMPLE_PATH]) dnl 结束check，继续执行
    EXAMPLE_LIB_NAME=`$EXAMPLE_PATH --libname`
    EXAMPLE_INCDIRS=`$EXAMPLE_PATH --incdirs`
    EXAMPLE_LIBS=`$EXAMPLE_PATH --libs`
    
    dnl 检测扩展库是否工作正常
    dnl PHP_CHECK_LIBRARY() 尝试编译、链接和执行程序，
    dnl 在第一个参数指定的库中调用由第二个参数指定的符号，使用第五个参数给出的字符串作为额外的链接选项。
    dnl 如果尝试成功了，则运行第三个参数所给出的脚本。此脚本从 example-config 所提供的原始的选项字符串中取出头文件路径、库文件路径和库名称，告诉 PHP 构建系统。
    dnl 如果尝试失败，脚本则运行第四个参数中的脚本。此时调用 AC_MSG_ERROR() 来中断程序执行。
    PHP_CHECK_LIBRARY($EXAMPLE_LIB_NAME, example_critical_function,
    [
      dnl 添加所需的 include 目录
      PHP_EVAL_INCLINE($EXAMPLE_INCDIRS)
      dnl 添加所需的扩展库及扩展库所在目录
      PHP_EVAL_LIBLINE($EXAMPLE_LIBS, EXAMPLE_SHARED_LIBADD)
    ],[
      dnl 跳出
      AC_MSG_ERROR([example library not found. Check config.log for more information.])
    ],[$EXAMPLE_LIBS]
    )
  else
    dnl 没有可用的 example-config，跳出
    AC_MSG_RESULT([not found])   dnl 结束check
    AC_MSG_ERROR([Please check your example installation.]) dnl 报错
  fi
  
  dnl 检测是否启用调试
  if test &quot;$PHP_EXAMPLE_DEBUG&quot; != &quot;no&quot;; then
    dnl 是，则设置 C 语言宏指令
    AC_DEFINE(USE_EXAMPLE_DEBUG,1,[Include debugging support in example])
  fi
  
  dnl 检测额外的支持
  if test &quot;$PHP_EXAMPLE_EXTRA&quot; != &quot;no&quot;; then
    if test &quot;$PHP_EXAMPLE_EXTRA&quot; == &quot;yes&quot;; then
      AC_MSG_ERROR([You must specify a path when using --with-example-extra])
    fi
    
    PHP_CHECK_LIBRARY(example-extra, example_critical_extra_function,
    [
      dnl 添加所需路径
      PHP_ADD_INCLUDE($PHP_EXAMPLE_EXTRA/include)
      PHP_ADD_LIBRARY_WITH_PATH(example-extra, $PHP_EXAMPLE_EXTRA/lib, EXAMPLE_SHARED_LIBADD)
      AC_DEFINE(HAVE_EXAMPLEEXTRALIB,1,[Whether example-extra support is present and requested])
      EXAMPLE_SOURCES=&quot;$EXAMPLE_SOURCES example_extra.c&quot;
    ],[
      AC_MSG_ERROR([example-extra lib not found. See config.log for more information.])
    ],[-L$PHP_EXAMPLE_EXTRA/lib]
    )
  fi
  
  dnl 最后，将扩展及其所需文件等信息传给构建系统
  dnl PHP_NEW_EXTENSION
  dnl 第一个参数是扩展的名称，和包含它的目录同名。
  dnl 第二个参数是做为扩展的一部分的所有源文件的列表。参见 PHP_ADD_BUILD_DIR() 以获取将在子目录中源文件添加到构建过程的相关信息。
  dnl 第三个参数总是 $ext_shared， 当为了 --with-example[=FILE] 而调用 PHP_ARG_WITH()时，由 configure 决定参数的值。
  dnl 第四个参数指定一个“SAPI 类”，仅用于专门需要 CGI 或 CLI SAPI 的扩展。其他情况下应留空。
  dnl 第五个参数指定了构建时要加入 CFLAGS 的标志列表。
  dnl 第六个参数是一个布尔值，为 &quot;yes&quot; 时会强迫整个扩展使用 $CXX 代替 $CC 来构建。
  dnl 第三个以后的所有参数都是可选的。
  PHP_NEW_EXTENSION(example, example.c $EXAMPLE_SOURCES, $ext_shared)
  dnl PHP_SUBST() 来启用扩展的共享构建
  PHP_SUBST(EXAMPLE_SHARED_LIBADD)
fi

</code></pre>

<h3 id="toc_5">3、编写扩展的功能</h3>

<p>在TestExtension.c文件中编写扩展实现的具体功能。</p>

<h2 id="toc_6">编译安装扩展的步骤</h2>

<h3 id="toc_7">1、使用phpize解析config.m4，生成configure及其他配置文件</h3>

<p>当代码量较少，结构简单的项目中，我们往往会手动编写Makefile文件，但是在大型项目中编写Makefile是很难的，于是出现了autoconf/automake/autoheader/autolocal等一系列用于生成configure的自动化工具。    </p>

<p>而phpize就是一款操作这一系列复杂工具的脚本，它会读取并解析config.m4文件，并以此生成configure及其他文件。    </p>

<p>使用方式：    </p>

<blockquote>
<p>在待编译的扩展目录使用 phpize 即可，如：</p>

<pre><code class="language-text">$ phpize
Configuring for:
PHP Api Version:        
Zend Module Api No:     
Zend Extension Api No:
</code></pre>
</blockquote>

<h3 id="toc_8">2、编译安装</h3>

<p>使用上一步生成的configure文件检测安装平台的特征：    </p>

<pre><code class="language-bash">./configure
</code></pre>

<p>你可以加上一些参数，例如：    </p>

<pre><code class="language-bash">./configure --with-php-config=php-config_path   
// php-config是在PHP安装时保存PHP安装信息的脚本，指定php-config更好
</code></pre>

<p>最后，使用make、make install命令完成扩展的安装。</p>

<p><em>Mission Complete!</em></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git Flow与git-flow的介绍]]></title>
    <link href="https://anhoder.github.io/15981624548765.html"/>
    <updated>2020-08-23T14:00:54+08:00</updated>
    <id>https://anhoder.github.io/15981624548765.html</id>
    <content type="html"><![CDATA[
<p>前两天在面试中，遇到GitFlow的问题，涉及到知识盲区，今天趁有空学习一下。</p>

<span id="more"></span><!-- more -->

<p><em>Mission Start!</em></p>

<h2 id="toc_0">什么是Git Flow</h2>

<p>Git Flow是2010年由<a href="https://nvie.com/about/">Vincent Driessen</a>提出的在进行产品开发时Git的行为规范（<a href="https://nvie.com/posts/a-successful-git-branching-model/">原文链接</a>）。类似的规范还有Github Flow、Gitlab Flow。</p>

<h2 id="toc_1">Git Flow的分支</h2>

<p>Git Flow中定义了两类分支：主分支、辅助分支。</p>

<blockquote>
<p>主分支用于组织与软件开发、部署相关的活动。主分支是所有开发活动的核心分支，可分为<code>master分支</code>、<code>develop分支</code>。</p>

<p>辅助分支是为了解决特定的问题而进行的各种开发活动。辅助分支有<code>feature分支</code>、<code>release分支</code>、<code>hotfix分支</code>。</p>
</blockquote>

<h3 id="toc_2">master分支</h3>

<p>master分支用于存放可上线的稳定代码。</p>

<ul>
<li>来源：<code>release分支</code>、<code>hotfix分支</code></li>
<li>去向：无</li>
</ul>

<h3 id="toc_3">develop分支</h3>

<p>develop 分支是开发的基础分支，当需要增加功能时可以从该分支切出一个 feature 分支。</p>

<ul>
<li>来源：<code>feature分支</code>、<code>release分支</code>、<code>hotfix分支</code></li>
<li>去向：<code>release分支</code></li>
</ul>

<h3 id="toc_4">feature分支</h3>

<p>当需要增加新功能时，使用 feature 分支。feature 分支从 develop 分支切出，完成时也要合并到 develop 分支。</p>

<ul>
<li>来源：<code>develop分支</code></li>
<li>去向：<code>develop分支</code></li>
</ul>

<h3 id="toc_5">release分支</h3>

<p>release 分支是发布到 master 分支前的版本。可以把已完成的 develop 分支合并到 release 分支，在该分支上做最后的测试。测试通过即可完成 release 分支，完成时会将 release 合并到 master 以及 develop 两个分支上。合并到 develop 分支是因为在 Release 分支上可能会有代码修改，需要将修改同步到 develop 分支上。</p>

<ul>
<li>来源：<code>develop分支</code></li>
<li>去向：<code>master分支</code>、<code>develop分支</code></li>
</ul>

<blockquote>
<p>常用命名：release-*</p>
</blockquote>

<h3 id="toc_6">hotfix分支</h3>

<p>当线上产品产生Bug时，从 master 分支开一个 hotfix 分支用于修复，修复完成后会合并到 master、develop 分支。</p>

<ul>
<li>来源：<code>master分支</code></li>
<li>去向：<code>master分支</code>、<code>develop分支</code></li>
</ul>

<blockquote>
<p>常用命名：hotfix-*</p>
</blockquote>

<h2 id="toc_7">总结</h2>

<p>以上分支的关系如下图所示（引用自<a href="https://segmentfault.com/a/1190000006194051">Git Flow简介</a>）：</p>

<p><img src="media/15981624548765/3652838737-57a69c4ba2103_articlex.png" alt="Git Flow分支"/></p>

<h2 id="toc_8">git-flow</h2>

<p>git-flow是配合Git Flow工作流程使用的一个Git扩展。可以简化Git Flow的操作。</p>

<h3 id="toc_9">安装</h3>

<p><strong>Mac OSX</strong></p>

<pre><code class="language-bash">brew install git-flow
</code></pre>

<p><strong>Debian/Ubuntu Linux</strong></p>

<pre><code class="language-bash">apt-get install git-flow
</code></pre>

<p><strong>Windows搭配Cygwin</strong></p>

<pre><code class="language-bash">wget -q -O - --no-check-certificate https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | bash
</code></pre>

<h3 id="toc_10">初始化</h3>

<pre><code class="language-bash">git flow init
</code></pre>

<h3 id="toc_11">feature</h3>

<ul>
<li>新建feature分支</li>
</ul>

<pre><code class="language-bash">git flow feature start FeatureName
</code></pre>

<ul>
<li>结束feature分支（将当前feature分支合并到develop；删除当前分支；并切换到develop分支）</li>
</ul>

<pre><code class="language-bash">git flow feature finish FeatureName
</code></pre>

<ul>
<li>公布feature分支（当需要与同伴一起开发时，将feature分支公布到服务器上）</li>
</ul>

<pre><code class="language-bash">git flow feature publish FeatureName
</code></pre>

<ul>
<li>从服务器上获取一个别人公布的feature分支</li>
</ul>

<pre><code class="language-bash">git flow feature pull origin FeatureName
</code></pre>

<h3 id="toc_12">release</h3>

<ul>
<li>创建一个release分支</li>
</ul>

<pre><code class="language-bash">git flow release start ReleaseName
</code></pre>

<ul>
<li>公布一个release分支</li>
</ul>

<pre><code class="language-bash">git flow release publish ReleaseName
</code></pre>

<ul>
<li>结束一个release分支（把release分支合并回master，给本次发布打tag；把release合并回develop；删除release分支）</li>
</ul>

<pre><code class="language-bash">git flow release finish ReleaseName
// 最后不要忘记把tag push到服务器：git push --tags
</code></pre>

<h3 id="toc_13">hotfix</h3>

<ul>
<li>创建一个hotfix分支</li>
</ul>

<pre><code class="language-bash">git flow hotfix start HotfixName
</code></pre>

<ul>
<li>结束一个hotfix分支（合并到develop、master分支，并删除hotfix分支）</li>
</ul>

<pre><code class="language-bash">git flow hotfix finish HotfixName
</code></pre>

<p><em>Mission Complete!</em></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git补坑]]></title>
    <link href="https://anhoder.github.io/15981624548821.html"/>
    <updated>2020-08-23T14:00:54+08:00</updated>
    <id>https://anhoder.github.io/15981624548821.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<p>这段时间一直忙着写作业和论文，心力交瘁，今天突然发现好久没写博客了（心痛的感觉QAQ），所以来给网站擦擦灰。。</p>

<p><em>Mission Start!</em></p>

<p>其实以前是很耐心学过Git的，只是没有写博客记录相关内容，现在来补上这个坑 :)   </p>

<p><span style="color:red;"><strong>值得注意的是：Git只能跟踪文本文件的内容变化，而不能跟踪二进制文件的内容变化（包括Word文档）</strong></span></p>

<h2 id="toc_0">一、安装Git</h2>

<blockquote>
<h3 id="toc_1">Windows</h3>

<p>在Windows下，可以在<a href="https://git-scm.com/downloads">官网</a>上下载Windows的安装程序进行安装，安装完成打开Git Bash即可。</p>

<h3 id="toc_2">Mac</h3>

<p>第一种方法：使用Homebrew进行安装（如果已经安装了<a href="https://brew.sh/index_zh-cn">Homebrew</a>的话），使用命令进行安装：</p>

<pre><code class="language-bash">brew install git
</code></pre>

<p>第二种方法：安装Xcode，Xcode集成了Git，但是默认未安装，你可以在Xcode的Preferences-&gt;Download中安装Command Line Tools。</p>

<h3 id="toc_3">Linux</h3>

<p>Linux不同的发行版有不同的安装方式，可以尝试使用以下方法：</p>

<pre><code class="language-bash">sudo apt-get install git
</code></pre>

<p>或者</p>

<pre><code class="language-bash">sudo yum install git
</code></pre>
</blockquote>

<p>安装完成后，使用</p>

<pre><code class="language-bash">git config --global user.name &quot;Your Name&quot;
git config --global user.email &quot;user@example.com&quot;
</code></pre>

<p>配置用户名和邮箱。</p>

<h2 id="toc_4">二、Git相关操作</h2>

<h3 id="toc_5">1.创建版本库(仓库，Repository)</h3>

<pre><code class="language-bash">$ mkdir Test  
$ cd Test
$ git init    // 创建仓库
Initialized empty Git repository in /Volumes/办公/Alan/Test/.git/
</code></pre>

<p>OK, 仓库已经建好，Git会在该目录下生成一个目录.git（.开头为隐藏目录），其用于跟踪管理这个仓库。   </p>

<p>如果使用的是某些特殊的shell，当切换到该目录时，可能会出现明显的变化，例如我使用的zsh，当执行git init创建好仓库后，切换到该目录下时（即Test），路径显示变成</p>

<pre><code class="language-bash">Test git:(master) ✗ $
</code></pre>

<h3 id="toc_6">2.添加文件到版本库</h3>

<p>添加文件到仓库，让Git跟踪该文件：</p>

<pre><code class="language-bash">$ touch readme.md     // 创建readme.md文件
$ git add readme.md   // 添加readme.md到仓库
$ git add test.php    // 添加test.php到仓库
</code></pre>

<h3 id="toc_7">3.提交文件到版本库</h3>

<pre><code class="language-bash">$ git commit -m &quot;add readme.me test.php&quot; // 提交到仓库（-m参数是提交的相关说明，添加提交说明至关重要）
</code></pre>

<p>可多次使用git add添加多个文件，然后使用git commit一次进行提交。每次的git commit都会生成一个新的版本。</p>

<h3 id="toc_8">4.查看提交日志</h3>

<pre><code class="language-bash">$ git log
</code></pre>

<p>显示结果为：</p>

<pre><code class="language-bash">commit bc916412b5b6ca835a21c72a530598db3ae38fb0 (HEAD -&gt; master)
Author: AlanAlbert &lt;1766447919@qq.com&gt;
Date:   Thu Jun 21 09:27:42 2018 +0800

    upload Sort

commit ee45db03f09b212562520be5c1a4e1d853064a2e
Author: AlanAlbert &lt;1766447919@qq.com&gt;
Date:   Thu Jun 21 09:17:41 2018 +0800

    upload readme.md test.php
</code></pre>

<p>git log会根据时间倒序显示每条提交记录，包括提交者、提交时间以及提交说明，也可以给git log加上参数--pretty=oneline让其只显示一行，只包括提交说明：</p>

<pre><code class="language-bash">bc916412b5b6ca835a21c72a530598db3ae38fb0 (HEAD -&gt; master) upload Sort
ee45db03f09b212562520be5c1a4e1d853064a2e upload readme.md test.php
</code></pre>

<p>上面两次都出现的很长一串的字符串是每次提交的id，其通过SHA1计算出来的十六进制数字，保证唯一性。</p>

<h3 id="toc_9">5.重置版本</h3>

<p>当前版本可以在git log的结果中看到，其用HEAD指向当前版本。上一个版本则为<code>HEAD^</code>，上上个版本为<code>HEAD^^</code>，上5个版本可以表示为<code>HEAD~5</code>。重置到上一个版本为：</p>

<pre><code class="language-bash">$ git reset --hard HEAD^
HEAD is now at ee45db0 upload readme.md test.php
</code></pre>

<p>使用git log --pretty=oneline显示结果：</p>

<pre><code class="language-bash">ee45db03f09b212562520be5c1a4e1d853064a2e (HEAD -&gt; master) upload readme.md test.php
</code></pre>

<p>可见HEAD指向了上一个commit版本。</p>

<blockquote>
<p>git reset命令将HEAD指向另一个commit版本，并将工作目录进行更新。</p>

<p>那么--hard参数是干什么的呢？git reset的参数有三个：--soft、--hard、--mixed，默认为mixed。</p>

<p>① <strong>--soft</strong>: HEAD指向另一个commit版本，而工作区和暂存区不发生变化。即，将HEAD头指针恢复，而add的缓存和工作区的所有东西都不变。</p>

<p>② <strong>--mixed</strong>: HEAD的指向、暂存区都发生变化，工作区不发生变化。即，将HEAD头指针恢复，add的缓存也会丢失，但工作区文件不变。</p>

<p>③ <strong>--hard</strong>: HEAD的指向、暂存区、工作区都发生变化。即，HEAD头指针恢复、add的缓存丢失、工作区的代码修改将恢复。</p>
</blockquote>

<p>在回退到上一个版本后，最新的那个版本不见了，如果又想回到最新的版本怎么办？<br/>
办法是有的，只要你知道最新版本的commit id，可以使用：</p>

<pre><code class="language-bash">$ git reset --hard bc91641
HEAD is now at bc91641 upload Sort
</code></pre>

<p>commit id并不需要输入完整，只要能够唯一区分目标版本即可。</p>

<blockquote>
<p>如果实在不记得版本的id，有两种方法可以进行查找，</p>

<p>第一种较简单：使用命令git reflog，第一列显示就是版本id</p>

<p>第二种比较麻烦：在日志文件.git/logs/refs/heads/master中查看，其内容如下：</p>

<pre><code class="language-bash">0000000000000000000000000000000000000000 ee45db03f09b212562520be5c1a4e1d853064a2e username &lt;user@example.com&gt; 1529543861 +0800    commit (initial): upload readme.md test.php
ee45db03f09b212562520be5c1a4e1d853064a2e bc916412b5b6ca835a21c72a530598db3ae38fb0 username &lt;user@example.com&gt; 1529544462 +0800    commit: upload Sort
/*结构组成如下：
上一个版本id 当前版本id 用户名 用户邮箱 时间戳 时区(+0800表示正8时区，北京所在时区) 执行的操作: 操作说明
</code></pre>
</blockquote>

<h3 id="toc_10">6.工作区 （working copy）和暂存区（staging copy）</h3>

<p>工作区不用多说，其就是我们可见的目录。<br/>
而在工作区下的隐藏文件夹.git下包含一个叫做stage或index的暂存区、第一个分支master以及指向master的指针HEAD，git add就是将文件添加至暂存区，git commit将暂存区的所有内容提交到当前分支，提交后暂存区的内容清空。   </p>

<h3 id="toc_11">7.查看状态</h3>

<p>使用git status可以查看状态：</p>

<pre><code class="language-bash">$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

  new file:   test1.php
    modified:   test2.php
    
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   test3.php

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
  
    test4.php

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>

<p>master分支下状态结果显示分三个状态：<br/><br/>
① Changes to be committed表示已添加到暂存区但未提交的修改<br/><br/>
② Changes not staged for commit表示被修改但未未添加到暂存区的修改，执行git add filename后该修改便会出现在状态① Changes to be committed中，并显示为modified: filename<br/><br/>
③ Untracked files表示未跟踪的文件，执行git add filename后该文件便会出现在状态① Changes to be committed中，并显示为new file: filename   </p>

<h3 id="toc_12">8.查看差异</h3>

<p>使用git diff HEAD可以显示最新提交版本和工作区的差异：</p>

<pre><code class="language-bash">$ git diff HEAD
diff --git a/test.php b/test.php
index 94fd6d7..46a8d83 100644
--- a/test.php
+++ b/test.php
@@ -1,7 +1,6 @@
 &lt;?php
 /**
- * add line
+ * test line
  */
    
diff --git a/test2.php b/test2.php
index 10d6ee9..4a3f8ca 100644
--- a/test2.php
+++ b/test2.php
@@ -1,6 +1,6 @@
 &lt;?php
-
+// test.line
</code></pre>

<p>因此，git diff HEAD会显示工作区和最新版本之间所有的差异，如果要检查某一个文件在工作区和最新提交版本之间的差异则使用git diff HEAD -- test.php：</p>

<pre><code class="language-bash">$git diff HEAD -- test.php
diff --git a/test.php b/test.php
index 94fd6d7..46a8d83 100644
--- a/test.php
+++ b/test.php
@@ -1,7 +1,6 @@
 &lt;?php
 /**
- * add line
+ * test line
  */
</code></pre>

<h3 id="toc_13">9.撤销修改</h3>

<p>对工作区进行修改后，如果想要放弃这次的修改可以使用：</p>

<pre><code class="language-bash">$ git checkout -- test.php
</code></pre>

<p>该命令会让工作区的文件回到最近一次git commit或git add时的状态。</p>

<h3 id="toc_14">10.删除文件</h3>

<p>当删除工作区的文件后，使用git status查看状态：</p>

<pre><code class="language-bash">$ git status 
Changes not staged for commit:
  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    deleted:    readme.md
    
</code></pre>

<p>可以使用以下命令删除版本库的filename文件：</p>

<pre><code class="language-bash">$ git rm filename
</code></pre>

<p>然后使用git commit将修改提交到版本库。</p>

<h3 id="toc_15">11.添加远程仓库</h3>

<p>以使用的较多的GitHub为例。<br/><br/>
首先，需要在GitHub上为你的账户配置ssh密钥，确保在电脑上可以通过GitHub的验证，可以在命令行或终端使用如下命令进行测试：</p>

<pre><code class="language-bash">$ ssh git@github.com
</code></pre>

<p>若结果显示为：</p>

<pre><code class="language-bash">PTY allocation request failed on channel 0
Hi username! You&#39;ve successfully authenticated, but GitHub does not provide shell access.
Connection to github.com closed.
</code></pre>

<p>则表示通过GitHub的验证；   </p>

<p>然后，使用命令关联远程仓库：</p>

<pre><code class="language-bash">$ git remote add origin git@github.com:username/test.git 
</code></pre>

<p>其中，origin为远程库的名字，然后使用git push将本地库内容推送到远程库：</p>

<pre><code class="language-bash">$ git push -u origin master
</code></pre>

<p>第一次推送时加上-u参数，Git不但会把master分支内容推送给远程新的master分支，还会把本地master分支和远程master分支关联起来。在以后将本地内容推送到远程仓库时，只需要使用以下命令即可：</p>

<pre><code class="language-bash">$ git push origin master
</code></pre>

<p>将远程库的更改合并至当前库：</p>

<pre><code class="language-bash">$ git pull origin master:test // 远程master与test分支合并
$ git pull origin master // 远程master和当前分支合并
</code></pre>

<h3 id="toc_16">11.从远程仓库克隆</h3>

<p>远程仓库的内容克隆到本地：</p>

<pre><code class="language-bash">$ git clone git@github.com:username/test.git
</code></pre>

<p>然后，Git就会下载远程仓库的内容到本地。<br/><br/>
Git默认使用的是ssh协议，除此之外还可以使用https等协议，例如：</p>

<pre><code class="language-bash">$ git clone https://github.com/username/test.git
</code></pre>

<h3 id="toc_17">12.分支管理</h3>

<p>首先了解一下分支是什么？每个分支都是一条timeline(时间线)，前面用到的分支就是master主分支，用户可以在分支上单独操作互不影响。<br/><br/>
创建test分支：</p>

<pre><code class="language-bash">$ git branch test
</code></pre>

<p>切换到test分支：</p>

<pre><code class="language-bash">$ git checkout test
Switched to branch &#39;test&#39;
</code></pre>

<p>以上两步也可以使用一个命令完成：</p>

<pre><code class="language-bash">$ git checkout -b test
</code></pre>

<p>查看所有分支（*号表示当前分支）：</p>

<pre><code class="language-bash">$ git branch
  master
* test
</code></pre>

<p>合并分支：</p>

<pre><code class="language-bash">$ git checkout master
$ git merge test
Updating 8d8593e..4b01548
Fast-forward
 google.md | 0
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 google.md
</code></pre>

<p>删除分支：</p>

<pre><code class="language-bash">$ git branch -d test
Deleted branch test (was cfc8d84).
</code></pre>

<p>为了更好的理解Git的分支，我们做一个小试验：</p>

<blockquote>
<p>① git init创建一个仓库</p>

<p>② 在master分支中新建readme.md，使用git add和git commit提交至仓库</p>

<p>③ 使用git checkout -b test1新建并切换至test1分支，在test1分支中新建并提交test1.md</p>

<p>④ 使用git checkout -b test2新建并切换至test2分支，在test2分支中新建并提交test2.md</p>

<p>⑤ 使用git checkout master切换至master分支，在master分支中新建test.md文件，并提交   </p>

<p>⑥ 此时，各分支状况如下图所示：</p>

<p><img src="https://media.alan123.xyz/imgs/blogs/git/1.png" alt="分支状况1"/></p>

<p>⑦ 在master、test1、test2分支中切换时，工作区的文件也会随之变化：切换到master时，工作区有readme.md和test.md；切换至test1分支时，工作区有readme.md和test1.md；切换至test2分支时，工作区有readme.md和test2.md文件</p>

<p>⑧ 切换至master分支，使用git merge test1 test2将test1和test2分支合并至master</p>

<p>⑨ 此时，master分支下的文件包含原来的readme.md、test.md以及加入的test1.md、test2.md，而test1和test2分支未发生变化</p>

<p>⑩ 这时的test1和test2可以用git branch -d test1 test2进行删除 </p>
</blockquote>

<p>那么，如果存在两个分支master、test，它们对同一个文件readme.md进行修改（master在文件末尾加入master line，test在文件末尾加入test line），这时，当将test分支合并到master分支时Git会报错。</p>

<pre><code class="language-bash">$ git merge test
Auto-merging readme.md
CONFLICT (content): Merge conflict in readme.md
Automatic merge failed; fix conflicts and then commit the result.
</code></pre>

<p>使用git status查看状态也会提示文件在两个分支都修改了：</p>

<pre><code class="language-bash">On branch master
Your branch is ahead of &#39;origin/master&#39; by 6 commits.
  (use &quot;git push&quot; to publish your local commits)

You have unmerged paths.
  (fix conflicts and run &quot;git commit&quot;)
  (use &quot;git merge --abort&quot; to abort the merge)

Unmerged paths:
  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)

    both modified:   readme.md

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>

<p>此时，需要手动对master主分支下的readme.md文件进行修改，使用vim readme.md打开文件：</p>

<pre><code class="language-bash">  1 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  2 master line
  3 =======
  4 test line
  5 &gt;&gt;&gt;&gt;&gt;&gt;&gt; test
</code></pre>

<p>Git将两个分支的readme.md的内容使用&lt;&lt;&lt;&lt;&lt;&lt;&lt;、=======、&gt;&gt;&gt;&gt;&gt;&gt;&gt;区分开来。将内容修改为目标内容，然后git add、git commit即可完成合并。（使用git log --graph可以查看分支合并图）</p>

<h3 id="toc_18">13.分支管理策略</h3>

<p>在合并分支时，如果不指定合并模式，Git会默认使用Fast forward模式，在这个模式下，删除分支信息后，会丢失分支信息。我们可以在合并分支时加上--no-ff参数禁用Fast forward模式，此时Git在合并时会生成一个新的commit：</p>

<pre><code class="language-bash">$ git merge --no-ff -m &#39;merge test&#39; test
</code></pre>

<p>使用git log --graph --pretty=oneline分别查看禁用Fast forward和不禁用时的区别：</p>

<pre><code class="language-bash"># 不禁用时：
$ git merge test
* 06cf0607846548da37edf16cba68a4b46ba95835 (HEAD -&gt; master) add test.md
* 9ee02e9c78cde794543df93ab508fefb2b7f7667 add readme.md

# 禁用时：
% git merge --no-ff -m &#39;merge test&#39; test
*   2e6de5d4c6f4c919d63b553615181f51411b3a99 (HEAD -&gt; master) merge test
|\  
| * bbfb8e492523ba516e69813ce7b6b09b7ccd3778 test.md
|/  
* 9ee02e9c78cde794543df93ab508fefb2b7f7667 add readme.md

</code></pre>

<h3 id="toc_19">14.隐藏改变</h3>

<p>当正在为一个Web应用程序进行升级时，突然发现当前版本的程序存在Bug，需要优先修复Bug，此时，升级的工作未完成，尚不能commit，而由于升级修改的文件会影响原来版本，怎么办？  </p>

<p>使用git stash命令即可隐藏工作区未提交的工作（前提需要将文件添加到仓库，使得Git能够追踪这些文件）。例如，在当前目录下创建test.md文件并添加至仓库，此时使用</p>

<pre><code class="language-bash">$ git stash
Saved working directory and index state WIP on master: 9ee02e9 add readme.md
</code></pre>

<p>此时，那些未上传的文件在工作区消失了，可以使用以下命令进行查看：</p>

<pre><code class="language-bash">$ git stash list
stash@{0}: WIP on master: 9ee02e9 add readme.md
</code></pre>

<p>Git将相对于最近commit的修改保存至一个类似队列的结构中，可以尝试在使用git stash后再次添加一个文件并使用git stash，然后使用git stash list即可查看到两个stash。   </p>

<p>隐藏后如何恢复呢？<br/><br/>
① 使用git stash apply，使用后stash的记录和内容不会删除，可以使用git stash drop进行删除；<br/><br/>
② 使用git stash pop弹出stash，在恢复的同时，删除stash   </p>

<h3 id="toc_20">15.标签管理</h3>

<p>添加标签：</p>

<pre><code class="language-bash">$ git tag v1.0
</code></pre>

<p>Git默认是为当前分支下的最新commit版本添加标签，如果想为历史提交的版本添加标签，添加上commit id即可：</p>

<pre><code class="language-bash">$ git tag v1.0 commitid
</code></pre>

<p>查看所有标签：</p>

<pre><code class="language-bash">$ git tag
v1.0
</code></pre>

<p>查看标签详细信息：</p>

<pre><code class="language-bash">$ git show v1.0
</code></pre>

<p>删除标签：</p>

<pre><code class="language-bash">$ git tag -d v1.0
</code></pre>

<p>本地标签不会自动推送至远程，可以手动推送至远程库：</p>

<pre><code class="language-bash">$ git push origin v1.0   // 推送标签名v1.0至远程库
$ git push origin --tags // 推送所有标签至远程库
</code></pre>

<p>删除远程库标签：</p>

<pre><code class="language-bash">$ git push origin :refs/tags/v1.0  // 删除标签v1.0
</code></pre>

<h3 id="toc_21">16.多人协作的工作流程</h3>

<p>多人协作的工作模式通常是这样：</p>

<ol>
<li><p>首先，可以试图用git push origin <branch-name>推送自己的修改；</p></li>
<li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p></li>
<li><p>如果合并有冲突，则解决冲突，并在本地提交；</p></li>
<li><p>没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！</p></li>
</ol>

<p>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to <branch-name> origin/<branch-name>。</p>

<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>

<h2 id="toc_22">三、总结</h2>

<p>善用Git的--help可以帮助更好的使用命令，例如：</p>

<pre><code class="language-bash">$ git --help
$ git pull --help
</code></pre>

<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>git config —global user.name “&lt; username &gt;&quot;</td>
<td>配置用户名</td>
</tr>
<tr>
<td>git config —global user.email “&lt; <a href="mailto:user@example.com">user@example.com</a> &gt;&quot;</td>
<td>配置邮箱</td>
</tr>
<tr>
<td>git init</td>
<td>创建版本库</td>
</tr>
<tr>
<td>git add &lt; file &gt;</td>
<td>添加文件到版本库（Git追踪该文件）</td>
</tr>
<tr>
<td>git commit -m “&lt; commit message &gt;&quot;</td>
<td>将改动提交到版本库</td>
</tr>
<tr>
<td>git log [--graph --pretty=oneline ...]</td>
<td>查看版本库日志信息</td>
</tr>
<tr>
<td>git reflog</td>
<td>查看所有分支的所有操作日志</td>
</tr>
<tr>
<td>git reset --hard &lt; version &gt;</td>
<td>重置版本,HEAD<sup>,HEAD~5,commit</sup> id</td>
</tr>
<tr>
<td>git status</td>
<td>查看状态</td>
</tr>
<tr>
<td>git diff &lt; version &gt; </td>
<td>查看版本和当前工作区差异</td>
</tr>
<tr>
<td>git checkout — &lt; file &gt;</td>
<td>恢复至最近commit或add时的状态</td>
</tr>
<tr>
<td>git rm &lt; file &gt;</td>
<td>从版本库删除文件</td>
</tr>
<tr>
<td>git remote add &lt; 远程库名 &gt; &lt; address &gt;</td>
<td>关联远程仓库（远程库名、地址）</td>
</tr>
<tr>
<td>git push [-u] &lt; 远程库名 &gt; &lt; branch &gt;</td>
<td>本地库内容推送至远程，第一次加-u（，分支）</td>
</tr>
<tr>
<td>git pull origin &lt; 远程分支名 &gt;:&lt; 本地分支名 &gt;</td>
<td>将远程库的更改合并至当前库</td>
</tr>
<tr>
<td>git clone &lt; address &gt;</td>
<td>远程仓库的内容克隆到本地</td>
</tr>
<tr>
<td>git branch &lt; branch &gt;</td>
<td>添加分支</td>
</tr>
<tr>
<td>git branch -d &lt; branch &gt;</td>
<td>删除分支</td>
</tr>
<tr>
<td>git branch</td>
<td>显示所有分支</td>
</tr>
<tr>
<td>git checkout &lt; branch &gt;</td>
<td>切换分支</td>
</tr>
<tr>
<td>git checkout -b &lt; branch &gt;</td>
<td>新建并切换分支</td>
</tr>
<tr>
<td>git merge &lt; branch &gt;</td>
<td>合并分支</td>
</tr>
<tr>
<td>git merge --no-ff -m “&lt; commit message &gt;” &lt; branch &gt;</td>
<td>禁用Fast forward模式合并分支</td>
</tr>
<tr>
<td>git stash</td>
<td>隐藏已跟踪未提交的工作区内容</td>
</tr>
<tr>
<td>git stash list</td>
<td>显示stash</td>
</tr>
<tr>
<td>git stash apply</td>
<td>恢复隐藏内容，但不删除</td>
</tr>
<tr>
<td>git stash drop</td>
<td>删除stash记录</td>
</tr>
<tr>
<td>git stash pop</td>
<td>恢复隐藏内容，并删除</td>
</tr>
<tr>
<td>git tag &lt; tag name &gt; [&lt; commit id &gt;]</td>
<td>添加标签</td>
</tr>
<tr>
<td>git tag</td>
<td>显示所有标签</td>
</tr>
<tr>
<td>git show &lt; tag name &gt;</td>
<td>显示tag详细信息</td>
</tr>
<tr>
<td>git tag -d &lt; tag name &gt;</td>
<td>删除标签</td>
</tr>
<tr>
<td>git push &lt; 远程库名 &gt; &lt; tag name &gt;</td>
<td>推送标签至远程库</td>
</tr>
<tr>
<td>git push &lt; 远程库名 &gt; --tags</td>
<td>推送所有标签至远程库</td>
</tr>
<tr>
<td>git push &lt; 远程库名 &gt; :refs/tags/&lt; tag name &gt;</td>
<td>删除远程库标签</td>
</tr>
</tbody>
</table>

<h2 id="toc_23">四、实际使用</h2>

<h3 id="toc_24">1、在GitHub上，修改他人项目的代码</h3>

<p>① 在GitHub上，将项目从他人仓库fork到自己仓库；</p>

<p>② 使用git clone将自己仓库的项目clone到本地；</p>

<p>③ 修改完代码后，将修改push到自己远程仓库；</p>

<p>④ 在GitHub上，创建Pull Request，等待原仓库管理员的审核；</p>

<h3 id="toc_25">2、Pull Request被合并后</h3>

<p>最近在GitHub上修改别人的代码，遇到一个问题：我在第二次提交Pull Request时，将第一次已合并的Pull Request再次提交了上去。（毕竟第一次嘛😂   </p>

<p>需要注意的是，在我们的Pull Request被合并时，我们需要做的工作有：</p>

<blockquote>
<p>① 给fork配置远程库：</p>

<p>使用<code>git remote -v</code>可以查看远程仓库状态。如果结果中没有原仓库的配置，可以使用<code>git remote add 自定义名 原仓库地址</code>进行配置，例如：<code>git remote add nickname https://github.com/username/repostory.git</code></p>

<p>② 使用<code>git fetch nickname</code>从原仓库fetch分支和提交点到本地，并存储到本地分支nickname/master</p>

<p>③ 切换到master分支：<code>git checkout master</code></p>

<p>④ 将nickname/master分支合并到本地master：<code>git merge nickname/master</code></p>

<p>⑤ 更新到GitHub的fork上：<code>git push origin master</code></p>

<p><strong>（原仓库即上游仓库）</strong></p>
</blockquote>

<p><em>Mission Complete!</em></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据库使用和设计的优化]]></title>
    <link href="https://anhoder.github.io/15981630682201.html"/>
    <updated>2020-08-23T14:11:08+08:00</updated>
    <id>https://anhoder.github.io/15981630682201.html</id>
    <content type="html"><![CDATA[
<p>自己收集的一些数据库设计和使用的优化方法。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">优化SQL语句</h2>

<ul>
<li>应避免全表扫描，首先应考虑在where和order by的列上建立索引</li>
<li><p>避免在where条件中进行null判断，且表的设计也应该尽量使用not null</p>
<blockquote>
<p>《高性能MySQL》书中提到：MySQL难以优化引用可为null的查询，它会使索引、索引统计和值更加复杂。可为null的列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MyISAM中固定大小的索引变成可变大小的索引。</p>
</blockquote></li>
<li><p>应避免使用<code>!=</code>或<code>&lt;&gt;</code>操作符，MySQL只有对以下操作才使用索引：<code>&lt;</code>、<code>&lt;=</code>、<code>=</code>、<code>=&gt;</code>、<code>&gt;</code>、<code>BETWEEN</code>、<code>IN</code>、以及形如<code>name LIKE &#39;Alan%&#39;</code>的<code>LIKE</code>(%放在后面，%放在前面的可以使用全文索引)</p></li>
<li><p>应避免在<code>where</code>中使用<code>or</code>来连接条件，否则会导致引擎放弃使用索引而进行全表扫描，可以使用<code>union all</code>进行联合查询</p></li>
<li><p>使用联合查询时，应尽量使用<code>union all</code>代替<code>union</code>，因为<code>union</code>会对结果进行去重</p></li>
<li><p><code>in</code>和<code>not in</code>也会导致全表扫描，对于连续的数值，应尽量使用<code>between ... and ...</code></p></li>
<li><p>避免在<code>where</code>中对字段进行<strong>表达式操作</strong>和<strong>函数操作</strong></p></li>
<li><p>避免在<code>where中</code>使用参数，其也会导致全表扫描。因为SQL在执行时才能解析局部变量，因此在编译时无法建立索引，可以修改为强制使用索引：<code>SELECT id FROM table FORCE INDEX(index_name) WHERE num=@num</code></p></li>
<li><p>可以使用<code>exists</code>代替<code>in</code></p></li>
<li><p>一张表的索引应尽量不多于6个，虽然索引可以加速查询，但同时也提高了索引的维护成本，降低插入数据及更新数据的速度</p></li>
<li><p>尽可能避免更新聚集(clustered)索引数据列，因为操作聚集索引会消耗相当大的资源（<a href="mweblib://15628148741975">聚集索引、非聚集索引及主键</a>）</p></li>
<li><p>只含数值信息的字段尽量使用数字型字段，以提高查询和连接的性能</p></li>
<li><p>使用<code>varchar</code>代替<code>char</code></p></li>
<li><p>查询时只查询需要的字段，而不是使用<code>*</code></p></li>
<li><p>当连接多个表时，使用<code>as</code>设置表的别名并使用别名访问列，如：<code>SELECT t1.name, t2.class_name FROM table1 AS t1 JOIN table2 AS t2 ON t1.class_id=t2.id</code></p></li>
<li><p>尽量少用子查询</p></li>
<li><p>不要超过5个以上的<code>JOIN</code>，可以使用中间变量或临时表存放中间结果</p></li>
<li><p>统计行数时使用<code>COUNT(*)</code></p></li>
<li><p>尽量使用<code>&gt;=</code>代替<code>&gt;</code></p></li>
<li><p>通过将不需要的记录在<code>GROUP BY</code>之前过滤掉</p></li>
<li><p>使用慢查询日志查看慢查询的语句</p></li>
<li><p>使用<code>explain</code>分析SQL语句的执行计划</p></li>
<li><p>使用<code>LIMIT</code>查询只需要的数据</p></li>
<li><p>建立索引<code>index(a,b,c)</code>，存储引擎不能使用索引范围条件右边的列作为索引，例如：<code>select * from where a=&#39;Alan&#39; and b&gt;25 and c=&#39;dev&#39;</code>，此时，只有a和b使用到索引</p></li>
<li><p>尽量只访问索引列的查询，避免<code>select *</code></p></li>
<li><p><code>is null</code>或<code>is not null</code>也会无法使用索引</p></li>
<li><p>隐式转换：<code>select * from test where name=123</code>，此时不会使用索引，应为<code>name</code>加上单引号</p></li>
<li><p>少用<code>or</code></p></li>
</ul>

<h2 id="toc_1">如何建立索引</h2>

<ul>
<li>每个表都需要主键索引</li>
<li>数据量超过300的表应该建立索引</li>
<li>对经常出现在where条件中或order by中的字段建立索引</li>
<li>经常需要与其他表进行连接的表，在其连接字段上建立索引</li>
<li>索引应该建立在数据量小的字段</li>
<li>频繁进行数据操作的表不应建立过多索引</li>
<li>复合索引应注意前缀原则</li>
</ul>

<h2 id="toc_2">慎用</h2>

<ul>
<li><code>NULL</code></li>
<li><code>!=</code>或<code>&lt;&gt;</code></li>
<li>形如<code>name LIKE %Alan</code>的<code>LIKE</code></li>
<li><code>IN</code>和<code>NOT IN</code></li>
<li><code>*</code></li>
<li>子查询</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SVN命令的使用]]></title>
    <link href="https://anhoder.github.io/15981624934747.html"/>
    <updated>2020-08-23T14:01:33+08:00</updated>
    <id>https://anhoder.github.io/15981624934747.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<p><em>Mission Start!</em></p>

<h2 id="toc_0">svnadmin</h2>

<h3 id="toc_1">1、使用svnadmin初始化SVN项目:</h3>

<pre><code class="language-bash">svnadmin create /home/user1/project
</code></pre>

<h3 id="toc_2">2、修改配置文件</h3>

<p>① 修改passwd，添加用户密码，例如：</p>

<pre><code class="language-ini">[users]
alan = 123456
</code></pre>

<p>② 修改权限文件authz，给用户设置权限：</p>

<pre><code class="language-ini">[aliases]

[groups]

[/]
alan = rw
</code></pre>

<p>③ 修改SVN服务器配置文件：</p>

<pre><code class="language-ini">[general]
# 以下两个配置的可选选项有read、write、none，read为只读权限，write为可读可写权限，none为不可读不可写
# 未认证用户权限
anon-access = read    
# 认证用户权限
auth-access = write  

# 用户密码数据，指定为第一步修改的文件
password-db = passwd
# 用户权限数据，指定为第二步修改的文件
authz-db = authz
</code></pre>

<h2 id="toc_3">svnserve</h2>

<p>svnserve命令用于启动SVN服务。可选参数有：</p>

<blockquote>
<p>-r: 指定SVN服务的root目录<br/>
-d: Daemon守护程序方式运行<br/>
-R: Read Only<br/>
-i: 超级服务器模式<br/>
-t: 隧道模式</p>
</blockquote>

<p>启动SVN服务：</p>

<pre><code class="language-bash">svnserve -d -r /home/user1/project
</code></pre>

<h2 id="toc_4">svn</h2>

<h3 id="toc_5">1、从SVN服务器下拉代码</h3>

<pre><code class="language-bash">svn chekout svn://127.0.0.1
// 或 svn co svn://127.0.0.1
</code></pre>

<h3 id="toc_6">2、查看当前工作目录下的文件状态</h3>

<pre><code class="language-bash">svn status
// 或 svn st
// ? 表示未在SVN的控制下
// M 表示已修改
// A 表示已添加
// D 表示已删除
// C 表示冲突文件
// I 表示忽略的文件
// R 表示被替换
</code></pre>

<h3 id="toc_7">3、查看当前工作目录下文件的版本差异</h3>

<pre><code class="language-bash">svn diff [file]
// file为可选参数，表示查看指定文件的差异
svn diff -r m:n file
// 查看m版本和n版本的文件差异

</code></pre>

<h3 id="toc_8">4、提交文件到SVN服务器</h3>

<pre><code class="language-bash">svn commit -m &#39;【新增】a.php&#39;
// 或 svn ci -m &#39;【新增】a.php&#39;
</code></pre>

<h3 id="toc_9">5、从SVN服务器更新文件到本地</h3>

<pre><code class="language-bash">svn update [file]
// 或 svn up [file]
// file为可选参数，表示只更新指定文件内容
</code></pre>

<h3 id="toc_10">6、加锁与解锁</h3>

<pre><code class="language-bash">// 加锁，锁定目录，让别人无法提交更新到这里
svn lock file -m &#39;【锁定】a.php&#39;
// 解锁
svn unlock file
</code></pre>

<h3 id="toc_11">7、查看SVN日志</h3>

<pre><code class="language-bash">svn log [file]
// 查看版本日志信息
</code></pre>

<h3 id="toc_12">8、查看文件或项目详细信息</h3>

<pre><code class="language-bash">svn info [file]
</code></pre>

<h3 id="toc_13">9、合并分支</h3>

<pre><code class="language-bash">svn merge -r m:n file
// 合并m版本和n版本的file文件差异，例如：svn merge -r 500:502 a.php
</code></pre>

<h3 id="toc_14">10、恢复本地修改</h3>

<pre><code class="language-bash">svn revert file
</code></pre>

<h3 id="toc_15">11、移除冲突状态</h3>

<p>在处理完文件冲突后，可以使用该命令移除文件冲突的状态：</p>

<pre><code class="language-bash">svn resolved file
</code></pre>

<h3 id="toc_16">SVN代码库表更</h3>

<pre><code class="language-bash">svn switch URL
</code></pre>

<p><em>Mission Complete!</em></p>

]]></content>
  </entry>
  
</feed>
